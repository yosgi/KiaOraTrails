import{a as e}from"./chunk-R3AL5FUL.js";import{a as t}from"./chunk-GHQSI7F2.js";import{a as n}from"./chunk-APUOR5ZJ.js";import{a as i}from"./chunk-ZPYKVVFF.js";import{a as r}from"./chunk-WNTCOVG2.js";import{a as a}from"./chunk-EEKB62LQ.js";import{b as o}from"./chunk-V3DSE3OK.js";import{a as l}from"./chunk-FMRIJYNG.js";import{c as s,d as u}from"./chunk-GSNDLQ4C.js";import{a as c,d as p}from"./chunk-BKSIEBAA.js";import{d as h,e as d,f as f,h as g}from"./chunk-YWRPWWKI.js";import{a as m}from"./chunk-VTVHUB7E.js";import{a as w,b as y,c as T,d as E,e as k}from"./chunk-JMSSU44E.js";import{a as _}from"./chunk-4UYSGV57.js";import"./chunk-ANLJ4KBN.js";import"./chunk-ID6SFQTL.js";import{a as O}from"./chunk-VLPNAR64.js";import{a as L,b as A}from"./chunk-GE5NEIZC.js";import{e as P}from"./chunk-35CVRQTC.js";function I(e){e=O(e,O.EMPTY_OBJECT),this._ellipsoid=O(e.ellipsoid,E.default),this._rectangle=O(e.rectangle,g.MAX_VALUE),this._projection=new c(this._ellipsoid),this._numberOfLevelZeroTilesX=O(e.numberOfLevelZeroTilesX,2),this._numberOfLevelZeroTilesY=O(e.numberOfLevelZeroTilesY,1)}Object.defineProperties(I.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},rectangle:{get:function(){return this._rectangle}},projection:{get:function(){return this._projection}}}),I.prototype.getNumberOfXTilesAtLevel=function(e){return this._numberOfLevelZeroTilesX<<e},I.prototype.getNumberOfYTilesAtLevel=function(e){return this._numberOfLevelZeroTilesY<<e},I.prototype.rectangleToNativeRectangle=function(e,t){A.defined("rectangle",e);let n=_.toDegrees(e.west),i=_.toDegrees(e.south),r=_.toDegrees(e.east),a=_.toDegrees(e.north);return P(t)?(t.west=n,t.south=i,t.east=r,t.north=a,t):new g(n,i,r,a)},I.prototype.tileXYToNativeRectangle=function(e,t,n,i){let r=this.tileXYToRectangle(e,t,n,i);return r.west=_.toDegrees(r.west),r.south=_.toDegrees(r.south),r.east=_.toDegrees(r.east),r.north=_.toDegrees(r.north),r},I.prototype.tileXYToRectangle=function(e,t,n,i){let r=this._rectangle,a=this.getNumberOfXTilesAtLevel(n),o=this.getNumberOfYTilesAtLevel(n),l=r.width/a,s=e*l+r.west,u=(e+1)*l+r.west,c=r.height/o,p=r.north-t*c,h=r.north-(t+1)*c;return P(i)||(i=new g(s,h,u,p)),i.west=s,i.south=h,i.east=u,i.north=p,i},I.prototype.positionToTileXY=function(e,t,n){let i=this._rectangle;if(!g.contains(i,e))return;let r=this.getNumberOfXTilesAtLevel(t),a=this.getNumberOfYTilesAtLevel(t),o=i.width/r,l=i.height/a,s=e.longitude;i.east<i.west&&(s+=_.TWO_PI);let u=(s-i.west)/o|0;u>=r&&(u=r-1);let c=(i.north-e.latitude)/l|0;return c>=a&&(c=a-1),P(n)?(n.x=u,n.y=c,n):new T(u,c)};var N=new w,S=new w,b=new y,v=new w,x=new w,j=new p,D=new I,M=[new y,new y,new y,new y],H=new T,C={};function R(e){y.fromRadians(e.east,e.north,0,M[0]),y.fromRadians(e.west,e.north,0,M[1]),y.fromRadians(e.east,e.south,0,M[2]),y.fromRadians(e.west,e.south,0,M[3]);let t=0,n=0,i=0,r=0,a=C._terrainHeightsMaxLevel,o;for(o=0;o<=a;++o){let e=!1;for(let t=0;t<4;++t){let n=M[t];if(D.positionToTileXY(n,o,H),0===t)i=H.x,r=H.y;else if(i!==H.x||r!==H.y){e=!0;break}}if(e)break;t=i,n=r}if(0!==o)return{x:t,y:n,level:o>a?a:o-1}}C.initialize=function(){let e=C._initPromise;return P(e)||(e=h.fetchJson(d("Assets/approximateTerrainHeights.json")).then(function(e){C._terrainHeights=e}),C._initPromise=e),e},C.getMinimumMaximumHeights=function(e,t){if(A.defined("rectangle",e),!P(C._terrainHeights))throw new L("You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function");t=O(t,E.default);let n=R(e),i=C._defaultMinTerrainHeight,r=C._defaultMaxTerrainHeight;if(P(n)){let a=`${n.level}-${n.x}-${n.y}`,o=C._terrainHeights[a];P(o)&&(i=o[0],r=o[1]),t.cartographicToCartesian(g.northeast(e,b),N),t.cartographicToCartesian(g.southwest(e,b),S),w.midpoint(S,N,v);let l=t.scaleToGeodeticSurface(v,x);i=P(l)?Math.min(i,-w.distance(v,l)):C._defaultMinTerrainHeight}return{minimumTerrainHeight:i=Math.max(C._defaultMinTerrainHeight,i),maximumTerrainHeight:r}},C.getBoundingSphere=function(e,t){if(A.defined("rectangle",e),!P(C._terrainHeights))throw new L("You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function");t=O(t,E.default);let n=R(e),i=C._defaultMaxTerrainHeight;if(P(n)){let e=`${n.level}-${n.x}-${n.y}`,t=C._terrainHeights[e];P(t)&&(i=t[1])}let r=p.fromRectangle3D(e,t,0);return p.fromRectangle3D(e,t,i,j),p.union(r,j,r)},C._terrainHeightsMaxLevel=6,C._defaultMaxTerrainHeight=9e3,C._defaultMinTerrainHeight=-1e5,C._terrainHeights=void 0,C._initPromise=void 0,Object.defineProperties(C,{initialized:{get:function(){return P(C._terrainHeights)}}});var z=[c,e],Y=z.length,B=Math.cos(_.toRadians(30)),F=Math.cos(_.toRadians(150));function G(e){let n=(e=O(e,O.EMPTY_OBJECT)).positions;if(!P(n)||n.length<2)throw new L("At least two positions are required.");if(P(e.arcType)&&e.arcType!==t.GEODESIC&&e.arcType!==t.RHUMB)throw new L("Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.");this.width=O(e.width,1),this._positions=n,this.granularity=O(e.granularity,9999),this.loop=O(e.loop,!1),this.arcType=O(e.arcType,t.GEODESIC),this._ellipsoid=E.default,this._projectionIndex=0,this._workerName="createGroundPolylineGeometry",this._scene3DOnly=!1}Object.defineProperties(G.prototype,{packedLength:{get:function(){return 1+3*this._positions.length+1+1+1+E.packedLength+1+1}}}),G.setProjectionAndEllipsoid=function(e,t){let n=0;for(let e=0;e<Y;e++)if(t instanceof z[e]){n=e;break}e._projectionIndex=n,e._ellipsoid=t.ellipsoid};var U=new w,V=new w,q=new w;function X(e,t,n,i,r){let a=ee(i,e,0,U),o=ee(i,e,n,V),l=ee(i,t,0,q),s=et(o,a,V),u=et(l,a,q);return w.cross(u,s,r),w.normalize(r,r)}var Z=new y,W=new w,J=new w,K=new w;function Q(e,n,r,o,l,s,u,c,p,h,d){let f;if(0===l)return;s===t.GEODESIC?f=new i(e,n,u):s===t.RHUMB&&(f=new a(e,n,u));let g=f.surfaceDistance;if(g<l)return;let m=X(e,n,o,u,K),y=Math.ceil(g/l),T=g/y,E=T,k=y-1,_=c.length;for(let e=0;e<k;e++){let e=f.interpolateUsingSurfaceDistance(E,Z),t=ee(u,e,r,W),n=ee(u,e,o,J);w.pack(m,c,_),w.pack(t,p,_),w.pack(n,h,_),d.push(e.latitude),d.push(e.longitude),_+=3,E+=T}}var $=new y;function ee(e,t,n,i){return y.clone(t,$),$.height=n,y.toCartesian($,e,i)}function et(e,t,n){return w.subtract(e,t,n),w.normalize(n,n),n}function en(e,t,n,i){return i=et(e,t,i),i=w.cross(i,n,i),i=w.normalize(i,i),i=w.cross(n,i,i)}G.pack=function(e,t,n){A.typeOf.object("value",e),A.defined("array",t);let i=O(n,0),r=e._positions,a=r.length;t[i++]=a;for(let e=0;e<a;++e){let n=r[e];w.pack(n,t,i),i+=3}return t[i++]=e.granularity,t[i++]=+!!e.loop,t[i++]=e.arcType,E.pack(e._ellipsoid,t,i),i+=E.packedLength,t[i++]=e._projectionIndex,t[i++]=+!!e._scene3DOnly,t},G.unpack=function(e,t,n){A.defined("array",e);let i=O(t,0),r=e[i++],a=Array(r);for(let t=0;t<r;t++)a[t]=w.unpack(e,i),i+=3;let o=e[i++],l=1===e[i++],s=e[i++],u=E.unpack(e,i);i+=E.packedLength;let c=e[i++],p=1===e[i++];return P(n)||(n=new G({positions:a})),n._positions=a,n.granularity=o,n.loop=l,n.arcType=s,n._ellipsoid=u,n._projectionIndex=c,n._scene3DOnly=p,n};var ei=new w,er=new w,ea=new w,eo=new w;function el(e,t,n,i,r){let a=et(n,t,eo),o=en(e,t,a,ei),l=en(i,t,a,er);if(_.equalsEpsilon(w.dot(o,l),-1,_.EPSILON5))return r=w.cross(a,o,r),r=w.normalize(r,r);r=w.add(l,o,r),r=w.normalize(r,r);let s=w.cross(a,r,ea);return 0>w.dot(l,s)&&(r=w.negate(r,r)),r}var es=l.fromPointNormal(w.ZERO,w.UNIT_Y),eu=new w,ec=new w,ep=new w,eh=new w,ed=new w,ef=new w,eg=new y,em=new y,ew=new y;G.createGeometry=function(e){let i=!e._scene3DOnly,l=e.loop,c=e._ellipsoid,h=e.granularity,d=e.arcType,f=new z[e._projectionIndex](c),T,E,k=e._positions,O=k.length;2===O&&(l=!1);let L,A,I,N,S=new a(void 0,void 0,c),b,v,x,j=[k[0]];for(E=0;E<O-1;E++)L=k[E],A=k[E+1],!P(b=o.lineSegmentPlane(L,A,es,ef))||w.equalsEpsilon(b,L,_.EPSILON7)||w.equalsEpsilon(b,A,_.EPSILON7)||(e.arcType===t.GEODESIC?j.push(w.clone(b)):e.arcType!==t.RHUMB||(x=c.cartesianToCartographic(b,eg).longitude,I=c.cartesianToCartographic(L,eg),N=c.cartesianToCartographic(A,em),S.setEndPoints(I,N),v=S.findIntersectionWithLongitude(x,ew),!P(b=c.cartographicToCartesian(v,ef))||w.equalsEpsilon(b,L,_.EPSILON7)||w.equalsEpsilon(b,A,_.EPSILON7)||j.push(w.clone(b)))),j.push(A);!l||(L=k[O-1],A=k[0],!P(b=o.lineSegmentPlane(L,A,es,ef))||w.equalsEpsilon(b,L,_.EPSILON7)||w.equalsEpsilon(b,A,_.EPSILON7)||(e.arcType===t.GEODESIC?j.push(w.clone(b)):e.arcType!==t.RHUMB||(x=c.cartesianToCartographic(b,eg).longitude,I=c.cartesianToCartographic(L,eg),N=c.cartesianToCartographic(A,em),S.setEndPoints(I,N),v=S.findIntersectionWithLongitude(x,ew),!P(b=c.cartographicToCartesian(v,ef))||w.equalsEpsilon(b,L,_.EPSILON7)||w.equalsEpsilon(b,A,_.EPSILON7)||j.push(w.clone(b)))));let D=j.length,M=Array(D);for(E=0;E<D;E++){let e=y.fromCartesian(j[E],c);e.height=0,M[E]=e}if((D=(M=r(M,y.equalsEpsilon)).length)<2)return;let H=[],R=[],Y=[],F=[],G=eu,U=ec,V=ep,q=eh,Z=ed,W=M[0],J=M[1];for(G=ee(c,M[D-1],0,G),q=ee(c,J,0,q),U=ee(c,W,0,U),V=ee(c,W,1e3,V),Z=l?el(G,U,V,q,Z):X(W,J,1e3,c,Z),w.pack(Z,R,0),w.pack(U,Y,0),w.pack(V,F,0),H.push(W.latitude),H.push(W.longitude),Q(W,J,0,1e3,h,d,c,R,Y,F,H),E=1;E<D-1;++E){G=w.clone(U,G),U=w.clone(q,U);let e=M[E];ee(c,e,1e3,V),ee(c,M[E+1],0,q),el(G,U,V,q,Z),T=R.length,w.pack(Z,R,T),w.pack(U,Y,T),w.pack(V,F,T),H.push(e.latitude),H.push(e.longitude),Q(M[E],M[E+1],0,1e3,h,d,c,R,Y,F,H)}let K=M[D-1],$=M[D-2];if(U=ee(c,K,0,U),V=ee(c,K,1e3,V),l){let e=M[0];Z=el(G=ee(c,$,0,G),U,V,q=ee(c,e,0,q),Z)}else Z=X($,K,1e3,c,Z);if(T=R.length,w.pack(Z,R,T),w.pack(U,Y,T),w.pack(V,F,T),H.push(K.latitude),H.push(K.longitude),l){for(Q(K,W,0,1e3,h,d,c,R,Y,F,H),T=R.length,E=0;E<3;++E)R[T+E]=R[E],Y[T+E]=Y[E],F[T+E]=F[E];H.push(W.latitude),H.push(W.longitude)}return function(e,t,i,r,a,o,l){let c,h,d,f=t._ellipsoid,y=i.length/3-1,T=8*y,E=4*T,k=36*y,O=T>65535?new Uint32Array(k):new Uint16Array(k),L=new Float64Array(3*T),A=new Float32Array(E),P=new Float32Array(E),I=new Float32Array(E),N=new Float32Array(E),S=new Float32Array(E),b,v,x,j;l&&(b=new Float32Array(E),v=new Float32Array(E),x=new Float32Array(E),j=new Float32Array(2*T));let D=o.length/2,M=0;ev.height=0,ex.height=0;let H=ej,R=eD;if(l)for(d=0,h=1;h<D;h++)ev.latitude=o[d],ev.longitude=o[d+1],ex.latitude=o[d+2],ex.longitude=o[d+3],H=t.project(ev,H),R=t.project(ex,R),M+=w.distance(H,R),d+=2;let z=r.length/3;R=w.unpack(r,0,R);let Y=0;for(d=3,h=1;h<z;h++)H=w.clone(R,H),R=w.unpack(r,d,R),Y+=w.distance(H,R),d+=3;d=3;let F=0,G=0,U=0,V=0,q=!1,X=w.unpack(i,0,eH),Z=w.unpack(r,0,eD),W=w.unpack(a,0,eR);e&&ek(W,w.unpack(i,i.length-6,eM),X,Z)&&(W=w.negate(W,W));let J=0,K=0,Q=0;for(h=0;h<y;h++){let e,s,u,p,h=w.clone(X,eM),m=w.clone(Z,ej),y=w.clone(W,eC);if(q&&(y=w.negate(y,y)),X=w.unpack(i,d,eH),Z=w.unpack(r,d,eD),q=ek(W=w.unpack(a,d,eR),h,X,Z),ev.latitude=o[F],ev.longitude=o[F+1],ex.latitude=o[F+2],ex.longitude=o[F+3],l){let n=function(e,t){let n=Math.abs(e.longitude),i=Math.abs(t.longitude);return _.equalsEpsilon(n,_.PI,_.EPSILON11)?(e.longitude=_.sign(t.longitude)*(n-_.EPSILON11),1):_.equalsEpsilon(i,_.PI,_.EPSILON11)?(t.longitude=_.sign(e.longitude)*(i-_.EPSILON11),2):0}(ev,ex);e=t.project(ev,eV);let i=et(s=t.project(ex,eq),e,e2);i.y=Math.abs(i.y),u=eX,p=eZ,0===n||w.dot(i,w.UNIT_Y)>B?(u=eA(t,ev,y,e,eX),p=eA(t,ex,W,s,eZ)):1===n?(p=eA(t,ex,W,s,eZ),u.x=0,u.y=_.sign(ev.longitude-Math.abs(ex.longitude)),u.z=0):(u=eA(t,ev,y,e,eX),p.x=0,p.y=_.sign(ev.longitude-ex.longitude),p.z=0)}let T=w.distance(m,Z),E=n.fromCartesian(h,e1),k=w.subtract(X,h,eW),O=w.normalize(k,eQ),D=w.subtract(m,h,eJ);D=w.normalize(D,D);let H=w.cross(O,D,eQ);H=w.normalize(H,H);let R=w.cross(D,y,e$);R=w.normalize(R,R);let z=w.subtract(Z,X,eK);z=w.normalize(z,z);let $=w.cross(W,z,e0);$=w.normalize($,$);let ee=T/Y,en=J/Y,ei=0,er,ea,eo,el=0,es=0;if(l){ei=w.distance(e,s),er=n.fromCartesian(e,e3),ea=w.subtract(s,e,e2);let t=(eo=w.normalize(ea,e5)).x;eo.x=eo.y,eo.y=-t,el=ei/M,es=K/M}for(c=0;c<8;c++){let e=V+4*c,t=G+2*c,n=e+3,i=c<4?1:-1,r=2===c||3===c||6===c||7===c?1:-1;w.pack(E.high,A,e),A[n]=k.x,w.pack(E.low,P,e),P[n]=k.y,w.pack(R,I,e),I[n]=k.z,w.pack($,N,e),N[n]=ee*i,w.pack(H,S,e);let a=en*r;0===a&&r<0&&(a=9),S[n]=a,l&&(b[e]=er.high.x,b[e+1]=er.high.y,b[e+2]=er.low.x,b[e+3]=er.low.y,x[e]=-u.y,x[e+1]=u.x,x[e+2]=p.y,x[e+3]=-p.x,v[e]=ea.x,v[e+1]=ea.y,v[e+2]=eo.x,v[e+3]=eo.y,j[t]=el*i,0==(a=es*r)&&r<0&&(a=9),j[t+1]=a)}let eu=g.fromCartographicArray(ez,eY),ec=C.getMinimumMaximumHeights(eu,f),ep=ec.minimumTerrainHeight,eh=ec.maximumTerrainHeight;Q+=Math.abs(ep),Q+=Math.abs(eh),eN(h,m,ep,eh,eG,eB),eN(X,Z,ep,eh,eU,eF);let ed=w.multiplyByScalar(H,_.EPSILON5,e7);w.add(eG,ed,eG),w.add(eU,ed,eU),w.add(eB,ed,eB),w.add(eF,ed,eF),eb(eG,eU),eb(eB,eF),w.pack(eG,L,U),w.pack(eU,L,U+3),w.pack(eF,L,U+6),w.pack(eB,L,U+9),ed=w.multiplyByScalar(H,-2*_.EPSILON5,e7),w.add(eG,ed,eG),w.add(eU,ed,eU),w.add(eB,ed,eB),w.add(eF,ed,eF),eb(eG,eU),eb(eB,eF),w.pack(eG,L,U+12),w.pack(eU,L,U+15),w.pack(eF,L,U+18),w.pack(eB,L,U+21),F+=2,d+=3,G+=16,U+=24,V+=32,J+=T,K+=ei}d=0;let $=0;for(h=0;h<y;h++){for(c=0;c<e9;c++)O[d+c]=e6[c]+$;$+=8,d+=e9}p.fromVertices(i,w.ZERO,3,e4[0]),p.fromVertices(r,w.ZERO,3,e4[1]);let ee=p.fromBoundingSpheres(e4);ee.radius+=Q/(2*y);let en={position:new u({componentDatatype:m.DOUBLE,componentsPerAttribute:3,normalize:!1,values:L}),startHiAndForwardOffsetX:e8(A),startLoAndForwardOffsetY:e8(P),startNormalAndForwardOffsetZ:e8(I),endNormalAndTextureCoordinateNormalizationX:e8(N),rightNormalAndTextureCoordinateNormalizationY:e8(S)};return l&&(en.startHiLo2D=e8(b),en.offsetAndRight2D=e8(v),en.startEndNormals2D=e8(x),en.texcoordNormalization2D=new u({componentDatatype:m.FLOAT,componentsPerAttribute:2,normalize:!1,values:j})),new s({attributes:en,indices:O,boundingSphere:ee})}(l,f,Y,F,R,H,i)};var ey=new w,eT=new k,eE=new f;function ek(e,t,n,i){let r=et(n,t,ey),a=w.dot(r,e);if(a>B||a<F){let t=et(i,n,eo),r=a<F?_.PI_OVER_TWO:-_.PI_OVER_TWO,o=f.fromAxisAngle(t,r,eE),l=k.fromQuaternion(o,eT);return k.multiplyByVector(l,e,e),!0}return!1}var e_=new y,eO=new w,eL=new w;function eA(e,t,n,i,r){let a=y.toCartesian(t,e._ellipsoid,eO),o=w.add(a,n,eL),l=!1,s=e._ellipsoid,u=s.cartesianToCartographic(o,e_);Math.abs(t.longitude-u.longitude)>_.PI_OVER_TWO&&(l=!0,o=w.subtract(a,n,eL),u=s.cartesianToCartographic(o,e_)),u.height=0;let c=e.project(u,r);return(r=w.subtract(c,i,r)).z=0,r=w.normalize(r,r),l&&w.negate(r,r),r}var eP=new w,eI=new w;function eN(e,t,n,i,r,a){let o=w.subtract(t,e,eP);w.normalize(o,o);let l=w.multiplyByScalar(o,n-0,eI);w.add(e,l,r),l=w.multiplyByScalar(o,i-1e3,eI),w.add(t,l,a)}var eS=new w;function eb(e,t){let n=l.getPointDistance(es,e),i=l.getPointDistance(es,t),r=eS;_.equalsEpsilon(n,0,_.EPSILON2)?(r=et(t,e,r),w.multiplyByScalar(r,_.EPSILON2,r),w.add(e,r,e)):_.equalsEpsilon(i,0,_.EPSILON2)&&(r=et(e,t,r),w.multiplyByScalar(r,_.EPSILON2,r),w.add(t,r,t))}var ev=new y,ex=new y,ej=new w,eD=new w,eM=new w,eH=new w,eC=new w,eR=new w,ez=[ev,ex],eY=new g,eB=new w,eF=new w,eG=new w,eU=new w,eV=new w,eq=new w,eX=new w,eZ=new w,eW=new w,eJ=new w,eK=new w,eQ=new w,e$=new w,e0=new w,e1=new n,e3=new n,e2=new w,e5=new w,e7=new w,e4=[new p,new p],e6=[0,2,1,0,3,2,0,7,3,0,4,7,0,5,4,0,1,5,5,7,4,5,6,7,5,2,6,5,1,2,3,6,2,3,7,6],e9=e6.length;function e8(e){return new u({componentDatatype:m.FLOAT,componentsPerAttribute:4,normalize:!1,values:e})}G._projectNormal=eA;var te=function(e,t){return C.initialize().then(function(){return P(t)&&(e=G.unpack(e,t)),G.createGeometry(e)})};export{te as default};