import{a as t}from"./chunk-ZFTFDHK4.js";import{a as e}from"./chunk-74GQJJ7R.js";import{a as i}from"./chunk-NNHN6WUY.js";import{a as n}from"./chunk-T7ERZ2CJ.js";import{b as a,c as r,d as o}from"./chunk-GSNDLQ4C.js";import{d as m}from"./chunk-BKSIEBAA.js";import{a as s}from"./chunk-VTVHUB7E.js";import{a as c,c as u,d as l}from"./chunk-JMSSU44E.js";import{a as f}from"./chunk-4UYSGV57.js";import{a as p}from"./chunk-VLPNAR64.js";import{a as h}from"./chunk-GE5NEIZC.js";import{e as _}from"./chunk-35CVRQTC.js";var d,k=new c,A=new c,y=new c,w=new c,C=new c,x=new c(1,1,1),P=Math.cos,v=Math.sin;function b(t){t=p(t,p.EMPTY_OBJECT);let i=p(t.radii,x),n=p(t.innerRadii,i),a=p(t.minimumClock,0),r=p(t.maximumClock,f.TWO_PI),o=p(t.minimumCone,0),m=p(t.maximumCone,f.PI),s=Math.round(p(t.stackPartitions,64)),u=Math.round(p(t.slicePartitions,64)),l=p(t.vertexFormat,e.DEFAULT);if(u<3)throw new h("options.slicePartitions cannot be less than three.");if(s<3)throw new h("options.stackPartitions cannot be less than three.");this._radii=c.clone(i),this._innerRadii=c.clone(n),this._minimumClock=a,this._maximumClock=r,this._minimumCone=o,this._maximumCone=m,this._stackPartitions=s,this._slicePartitions=u,this._vertexFormat=e.clone(l),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidGeometry"}b.packedLength=2*c.packedLength+e.packedLength+7,b.pack=function(t,i,n){if(!_(t))throw new h("value is required");if(!_(i))throw new h("array is required");return n=p(n,0),c.pack(t._radii,i,n),n+=c.packedLength,c.pack(t._innerRadii,i,n),n+=c.packedLength,e.pack(t._vertexFormat,i,n),n+=e.packedLength,i[n++]=t._minimumClock,i[n++]=t._maximumClock,i[n++]=t._minimumCone,i[n++]=t._maximumCone,i[n++]=t._stackPartitions,i[n++]=t._slicePartitions,i[n]=p(t._offsetAttribute,-1),i};var g=new c,T=new c,F=new e,L={radii:g,innerRadii:T,vertexFormat:F,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};b.unpack=function(t,i,n){if(!_(t))throw new h("array is required");i=p(i,0);let a=c.unpack(t,i,g);i+=c.packedLength;let r=c.unpack(t,i,T);i+=c.packedLength;let o=e.unpack(t,i,F);i+=e.packedLength;let m=t[i++],s=t[i++],u=t[i++],l=t[i++],f=t[i++],d=t[i++],k=t[i];return _(n)?(n._radii=c.clone(a,n._radii),n._innerRadii=c.clone(r,n._innerRadii),n._vertexFormat=e.clone(o,n._vertexFormat),n._minimumClock=m,n._maximumClock=s,n._minimumCone=u,n._maximumCone=l,n._stackPartitions=f,n._slicePartitions=d,n._offsetAttribute=-1===k?void 0:k,n):(L.minimumClock=m,L.maximumClock=s,L.minimumCone=u,L.maximumCone=l,L.stackPartitions=f,L.slicePartitions=d,L.offsetAttribute=-1===k?void 0:k,new b(L))},b.createGeometry=function(e){let p,h,d,x,b=e._radii;if(b.x<=0||b.y<=0||b.z<=0)return;let g=e._innerRadii;if(g.x<=0||g.y<=0||g.z<=0)return;let T=e._minimumClock,F=e._maximumClock,L=e._minimumCone,E=e._maximumCone,N=e._vertexFormat,I=e._slicePartitions+1,O=e._stackPartitions+1;I=Math.round(I*Math.abs(F-T)/f.TWO_PI),O=Math.round(O*Math.abs(E-L)/f.PI),I<2&&(I=2),O<2&&(O=2);let M,j,z=0,R=[L],D=[T];for(M=0;M<O;M++)R.push(L+M*(E-L)/(O-1));for(R.push(E),j=0;j<I;j++)D.push(T+j*(F-T)/(I-1));D.push(F);let U=R.length,S=D.length,G=0,B=1,J=g.x!==b.x||g.y!==b.y||g.z!==b.z,V=!1,W=!1,Y=!1;J&&(B=2,L>0&&(V=!0,G+=I-1),E<Math.PI&&(W=!0,G+=I-1),(F-T)%f.TWO_PI?(Y=!0,G+=(O-1)*2+1):G+=1);let Z=S*U*B,q=new Float64Array(3*Z),H=Array(Z).fill(!1),K=Array(Z).fill(!1),Q=I*O*B,X=6*(Q+G+1-(I+O)*B),$=i.createTypedArray(Q,X),tt=N.normal?new Float32Array(3*Z):void 0,te=N.tangent?new Float32Array(3*Z):void 0,ti=N.bitangent?new Float32Array(3*Z):void 0,tn=N.st?new Float32Array(2*Z):void 0,ta=Array(U),tr=Array(U);for(M=0;M<U;M++)ta[M]=v(R[M]),tr[M]=P(R[M]);let to=Array(S),tm=Array(S);for(j=0;j<S;j++)tm[j]=P(D[j]),to[j]=v(D[j]);for(M=0;M<U;M++)for(j=0;j<S;j++)q[z++]=b.x*ta[M]*tm[j],q[z++]=b.y*ta[M]*to[j],q[z++]=b.z*tr[M];let ts=Z/2;if(J)for(M=0;M<U;M++)for(j=0;j<S;j++)q[z++]=g.x*ta[M]*tm[j],q[z++]=g.y*ta[M]*to[j],q[z++]=g.z*tr[M],H[ts]=!0,M>0&&M!==U-1&&0!==j&&j!==S-1&&(K[ts]=!0),ts++;for(M=1,z=0;M<U-2;M++)for(p=M*S,h=(M+1)*S,j=1;j<S-2;j++)$[z++]=h+j,$[z++]=h+j+1,$[z++]=p+j+1,$[z++]=h+j,$[z++]=p+j+1,$[z++]=p+j;if(J){let t=U*S;for(M=1;M<U-2;M++)for(p=t+M*S,h=t+(M+1)*S,j=1;j<S-2;j++)$[z++]=h+j,$[z++]=p+j,$[z++]=p+j+1,$[z++]=h+j,$[z++]=p+j+1,$[z++]=h+j+1}if(J){if(V)for(x=U*S,M=1;M<S-2;M++)$[z++]=M,$[z++]=M+1,$[z++]=x+M+1,$[z++]=M,$[z++]=x+M+1,$[z++]=x+M;if(W)for(d=U*S-S,x=U*S*B-S,M=1;M<S-2;M++)$[z++]=d+M+1,$[z++]=d+M,$[z++]=x+M,$[z++]=d+M+1,$[z++]=x+M,$[z++]=x+M+1}if(Y){for(M=1;M<U-2;M++)x=S*U+S*M,d=S*M,$[z++]=x,$[z++]=d+S,$[z++]=d,$[z++]=x,$[z++]=x+S,$[z++]=d+S;for(M=1;M<U-2;M++)x=S*U+S*(M+1)-1,d=S*(M+1)-1,$[z++]=d+S,$[z++]=x,$[z++]=d,$[z++]=d+S,$[z++]=x+S,$[z++]=x}let tc=new n;N.position&&(tc.position=new o({componentDatatype:s.DOUBLE,componentsPerAttribute:3,values:q}));let tu=0,tl=0,tf=0,tp=0,th=Z/2,t_,td=l.fromCartesian3(b),tk=l.fromCartesian3(g);if(N.st||N.normal||N.tangent||N.bitangent){for(M=0;M<Z;M++){t_=H[M]?tk:td;let t=c.fromArray(q,3*M,k),e=t_.geodeticSurfaceNormal(t,A);if(K[M]&&c.negate(e,e),N.st){let t=u.negate(e,C);tn[tu++]=Math.atan2(t.y,t.x)/f.TWO_PI+.5,tn[tu++]=Math.asin(e.z)/Math.PI+.5}if(N.normal&&(tt[tl++]=e.x,tt[tl++]=e.y,tt[tl++]=e.z),N.tangent||N.bitangent){let t=0,i;if(H[M]&&(t=th),i=!V&&M>=t&&M<t+2*S?c.UNIT_X:c.UNIT_Z,c.cross(i,e,y),c.normalize(y,y),N.tangent&&(te[tf++]=y.x,te[tf++]=y.y,te[tf++]=y.z),N.bitangent){let t=c.cross(e,y,w);c.normalize(t,t),ti[tp++]=t.x,ti[tp++]=t.y,ti[tp++]=t.z}}}N.st&&(tc.st=new o({componentDatatype:s.FLOAT,componentsPerAttribute:2,values:tn})),N.normal&&(tc.normal=new o({componentDatatype:s.FLOAT,componentsPerAttribute:3,values:tt})),N.tangent&&(tc.tangent=new o({componentDatatype:s.FLOAT,componentsPerAttribute:3,values:te})),N.bitangent&&(tc.bitangent=new o({componentDatatype:s.FLOAT,componentsPerAttribute:3,values:ti}))}if(_(e._offsetAttribute)){let i=q.length,n=+(e._offsetAttribute!==t.NONE),a=new Uint8Array(i/3).fill(n);tc.applyOffset=new o({componentDatatype:s.UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}return new r({attributes:tc,indices:$,primitiveType:a.TRIANGLES,boundingSphere:m.fromEllipsoid(td),offsetAttribute:e._offsetAttribute})},b.getUnitEllipsoid=function(){return _(d)||(d=b.createGeometry(new b({radii:new c(1,1,1),vertexFormat:e.POSITION_ONLY}))),d};var E=b;export{E as a};