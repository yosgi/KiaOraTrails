import{a as e}from"./chunk-JS6PT4NQ.js";import{a as t}from"./chunk-GHQSI7F2.js";import{a as o}from"./chunk-M5SITFFN.js";import"./chunk-ZPYKVVFF.js";import"./chunk-EEKB62LQ.js";import"./chunk-V3DSE3OK.js";import"./chunk-FMRIJYNG.js";import{a as r}from"./chunk-NNHN6WUY.js";import{a as a}from"./chunk-T7ERZ2CJ.js";import{b as n,c as i,d as l}from"./chunk-GSNDLQ4C.js";import{d as s}from"./chunk-BKSIEBAA.js";import"./chunk-YWRPWWKI.js";import{a as p}from"./chunk-VTVHUB7E.js";import{a as c,d as h}from"./chunk-JMSSU44E.js";import{a as u}from"./chunk-4UYSGV57.js";import"./chunk-ANLJ4KBN.js";import"./chunk-ID6SFQTL.js";import{a as f}from"./chunk-VLPNAR64.js";import{a as m}from"./chunk-GE5NEIZC.js";import{e as y}from"./chunk-35CVRQTC.js";function d(o){let r=(o=f(o,f.EMPTY_OBJECT)).positions,a=o.colors,n=f(o.colorsPerVertex,!1);if(!y(r)||r.length<2)throw new m("At least two positions are required.");if(y(a)&&(n&&a.length<r.length||!n&&a.length<r.length-1))throw new m("colors has an invalid length.");this._positions=r,this._colors=a,this._colorsPerVertex=n,this._arcType=f(o.arcType,t.GEODESIC),this._granularity=f(o.granularity,u.RADIANS_PER_DEGREE),this._ellipsoid=f(o.ellipsoid,h.default),this._workerName="createSimplePolylineGeometry";let i=1+r.length*c.packedLength;i+=y(a)?1+a.length*e.packedLength:1,this.packedLength=i+h.packedLength+3}d.pack=function(t,o,r){if(!y(t))throw new m("value is required");if(!y(o))throw new m("array is required");r=f(r,0);let a,n=t._positions,i=n.length;for(o[r++]=i,a=0;a<i;++a,r+=c.packedLength)c.pack(n[a],o,r);let l=t._colors;for(i=y(l)?l.length:0,o[r++]=i,a=0;a<i;++a,r+=e.packedLength)e.pack(l[a],o,r);return h.pack(t._ellipsoid,o,r),r+=h.packedLength,o[r++]=+!!t._colorsPerVertex,o[r++]=t._arcType,o[r]=t._granularity,o},d.unpack=function(t,o,r){if(!y(t))throw new m("array is required");o=f(o,0);let a,n=t[o++],i=Array(n);for(a=0;a<n;++a,o+=c.packedLength)i[a]=c.unpack(t,o);let l=(n=t[o++])>0?Array(n):void 0;for(a=0;a<n;++a,o+=e.packedLength)l[a]=e.unpack(t,o);let s=h.unpack(t,o);o+=h.packedLength;let p=1===t[o++],u=t[o++],g=t[o];return y(r)?(r._positions=i,r._colors=l,r._ellipsoid=s,r._colorsPerVertex=p,r._arcType=u,r._granularity=g,r):new d({positions:i,colors:l,ellipsoid:s,colorsPerVertex:p,arcType:u,granularity:g})};var g=[,,],k=[,,],T={positions:g,height:k,ellipsoid:void 0,minDistance:void 0,granularity:void 0};d.createGeometry=function(h){let f=h._positions,m=h._colors,d=h._colorsPerVertex,B=h._arcType,_=h._granularity,E=h._ellipsoid,w=u.chordLength(_,E.maximumRadius),j=y(m)&&!d,A,L=f.length,P,S,b,N,D=0;if(B===t.GEODESIC||B===t.RHUMB){let r,a,n;B===t.GEODESIC?(r=u.chordLength(_,E.maximumRadius),a=o.numberOfPoints,n=o.generateArc):(r=_,a=o.numberOfPointsRhumbLine,n=o.generateRhumbArc);let i=o.extractHeights(f,E);if(B===t.GEODESIC?T.minDistance=w:T.granularity=_,T.ellipsoid=E,j){let t=0;for(A=0;A<L-1;A++)t+=a(f[A],f[A+1],r)+1;P=new Float64Array(3*t),b=new Uint8Array(4*t),T.positions=g,T.height=k;let o=0;for(A=0;A<L-1;++A){g[0]=f[A],g[1]=f[A+1],k[0]=i[A],k[1]=i[A+1];let t=n(T);if(y(m)){let r=t.length/3;N=m[A];for(let t=0;t<r;++t)b[o++]=e.floatToByte(N.red),b[o++]=e.floatToByte(N.green),b[o++]=e.floatToByte(N.blue),b[o++]=e.floatToByte(N.alpha)}P.set(t,D),D+=t.length}}else if(T.positions=f,T.height=i,P=new Float64Array(n(T)),y(m)){for(b=new Uint8Array(P.length/3*4),A=0;A<L-1;++A)D=function(t,r,a,n,i,l,s){let p=o.numberOfPoints(t,r,i),c,h=a.red,u=a.green,f=a.blue,m=a.alpha,y=n.red,d=n.green,g=n.blue,k=n.alpha;if(e.equals(a,n)){for(c=0;c<p;c++)l[s++]=e.floatToByte(h),l[s++]=e.floatToByte(u),l[s++]=e.floatToByte(f),l[s++]=e.floatToByte(m);return s}let T=(y-h)/p,B=(d-u)/p,_=(g-f)/p,E=(k-m)/p,w=s;for(c=0;c<p;c++)l[w++]=e.floatToByte(h+c*T),l[w++]=e.floatToByte(u+c*B),l[w++]=e.floatToByte(f+c*_),l[w++]=e.floatToByte(m+c*E);return w}(f[A],f[A+1],m[A],m[A+1],w,b,D);let t=m[L-1];b[D++]=e.floatToByte(t.red),b[D++]=e.floatToByte(t.green),b[D++]=e.floatToByte(t.blue),b[D++]=e.floatToByte(t.alpha)}}else{P=new Float64Array(3*(S=j?2*L-2:L)),b=y(m)?new Uint8Array(4*S):void 0;let t=0,o=0;for(A=0;A<L;++A){let r=f[A];if(j&&A>0&&(c.pack(r,P,t),t+=3,N=m[A-1],b[o++]=e.floatToByte(N.red),b[o++]=e.floatToByte(N.green),b[o++]=e.floatToByte(N.blue),b[o++]=e.floatToByte(N.alpha)),j&&A===L-1)break;c.pack(r,P,t),t+=3,y(m)&&(N=m[A],b[o++]=e.floatToByte(N.red),b[o++]=e.floatToByte(N.green),b[o++]=e.floatToByte(N.blue),b[o++]=e.floatToByte(N.alpha))}}let G=new a;G.position=new l({componentDatatype:p.DOUBLE,componentsPerAttribute:3,values:P}),y(m)&&(G.color=new l({componentDatatype:p.UNSIGNED_BYTE,componentsPerAttribute:4,values:b,normalize:!0}));let I=((S=P.length/3)-1)*2,V=r.createTypedArray(S,I),R=0;for(A=0;A<S-1;++A)V[R++]=A,V[R++]=A+1;return new i({attributes:G,indices:V,primitiveType:n.LINES,boundingSphere:s.fromPoints(f)})};var B=function(e,t){return y(t)&&(e=d.unpack(e,t)),e._ellipsoid=h.clone(e._ellipsoid),d.createGeometry(e)};export{B as default};