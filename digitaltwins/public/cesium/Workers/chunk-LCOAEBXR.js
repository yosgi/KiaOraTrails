import{a as t}from"./chunk-IPMQ7HU7.js";import{a as e}from"./chunk-KM43AUZL.js";import{a as i}from"./chunk-AOALMXNW.js";import{a as o}from"./chunk-ZFTFDHK4.js";import{a as r}from"./chunk-74GQJJ7R.js";import{a as n}from"./chunk-NNHN6WUY.js";import{a as a}from"./chunk-T7ERZ2CJ.js";import{b as s,c as l,d as u}from"./chunk-GSNDLQ4C.js";import{a as m,d as c}from"./chunk-BKSIEBAA.js";import{f as p,h as h}from"./chunk-YWRPWWKI.js";import{a as f}from"./chunk-VTVHUB7E.js";import{a as d,b as A,c as y,d as x,e as g}from"./chunk-JMSSU44E.js";import{a as _}from"./chunk-4UYSGV57.js";import{a as w}from"./chunk-VLPNAR64.js";import{a as b,b as N}from"./chunk-GE5NEIZC.js";import{e as T}from"./chunk-35CVRQTC.js";var I=new d,E=new d,M=new d,v=new d,P=new y,j=new g,F=new g,O=new p,S=new d,R=new d,k=new d,L=new A,D=new d,V=new y,z=new y;function G(e,i,r){let n=i.vertexFormat,s=i.center,l=i.semiMajorAxis,c=i.semiMinorAxis,h=i.ellipsoid,A=i.stRotation,x=r?e.length/3*2:e.length/3,_=i.shadowVolume,w=n.st?new Float32Array(2*x):void 0,b=n.normal?new Float32Array(3*x):void 0,N=n.tangent?new Float32Array(3*x):void 0,v=n.bitangent?new Float32Array(3*x):void 0,G=_?new Float32Array(3*x):void 0,Y=0,B=S,C=R,H=k,U=new m(h),Q=U.project(h.cartesianToCartographic(s,L),D),W=h.scaleToGeodeticSurface(s,I);h.geodeticSurfaceNormal(W,W);let J=j,Z=F;if(0!==A){let t=p.fromAxisAngle(W,A,O);J=g.fromQuaternion(t,J),t=p.fromAxisAngle(W,-A,O),Z=g.fromQuaternion(t,Z)}else J=g.clone(g.IDENTITY,J),Z=g.clone(g.IDENTITY,Z);let K=y.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,V),q=y.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,z),X=e.length,$=r?X:0,tt=$/3*2;for(let t=0;t<X;t+=3){let i=t+1,o=t+2,a=d.fromArray(e,t,I);if(n.st){let t=g.multiplyByVector(J,a,E),e=U.project(h.cartesianToCartographic(t,L),M);d.subtract(e,Q,e),P.x=(e.x+l)/(2*l),P.y=(e.y+c)/(2*c),K.x=Math.min(P.x,K.x),K.y=Math.min(P.y,K.y),q.x=Math.max(P.x,q.x),q.y=Math.max(P.y,q.y),r&&(w[Y+tt]=P.x,w[Y+1+tt]=P.y),w[Y++]=P.x,w[Y++]=P.y}(n.normal||n.tangent||n.bitangent||_)&&(B=h.geodeticSurfaceNormal(a,B),_&&(G[t+$]=-B.x,G[i+$]=-B.y,G[o+$]=-B.z),(n.normal||n.tangent||n.bitangent)&&((n.tangent||n.bitangent)&&(C=d.normalize(d.cross(d.UNIT_Z,B,C),C),g.multiplyByVector(Z,C,C)),n.normal&&(b[t]=B.x,b[i]=B.y,b[o]=B.z,r&&(b[t+$]=-B.x,b[i+$]=-B.y,b[o+$]=-B.z)),n.tangent&&(N[t]=C.x,N[i]=C.y,N[o]=C.z,r&&(N[t+$]=-C.x,N[i+$]=-C.y,N[o+$]=-C.z)),n.bitangent&&(H=d.normalize(d.cross(B,C,H),H),v[t]=H.x,v[i]=H.y,v[o]=H.z,r&&(v[t+$]=H.x,v[i+$]=H.y,v[o+$]=H.z))))}if(n.st){X=w.length;for(let t=0;t<X;t+=2)w[t]=(w[t]-K.x)/(q.x-K.x),w[t+1]=(w[t+1]-K.y)/(q.y-K.y)}let te=new a;if(n.position){let o=t.raisePositionsToHeight(e,i,r);te.position=new u({componentDatatype:f.DOUBLE,componentsPerAttribute:3,values:o})}if(n.st&&(te.st=new u({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:w})),n.normal&&(te.normal=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:b})),n.tangent&&(te.tangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:N})),n.bitangent&&(te.bitangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:v})),_&&(te.extrudeDirection=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:G})),r&&T(i.offsetAttribute)){let t=new Uint8Array(x);if(i.offsetAttribute===o.TOP)t=t.fill(1,0,x/2);else{let e=+(i.offsetAttribute!==o.NONE);t=t.fill(e)}te.applyOffset=new u({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return te}function Y(t){let e=Array(t*(t+1)*12-6),i=0,o,r,n,a,s;for(o=0,n=1,a=0;a<3;a++)e[i++]=n++,e[i++]=o,e[i++]=n;for(a=2;a<t+1;++a){for(n=a*(a+1)-1,o=(a-1)*a-1,e[i++]=n++,e[i++]=o,e[i++]=n,r=2*a,s=0;s<r-1;++s)e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o,e[i++]=n;e[i++]=n++,e[i++]=o,e[i++]=n}for(r=2*t,++n,++o,a=0;a<r-1;++a)e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o,e[i++]=n;for(e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o++,e[i++]=o,++o,a=t-1;a>1;--a){for(e[i++]=o++,e[i++]=o,e[i++]=n,r=2*a,s=0;s<r-1;++s)e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o,e[i++]=n;e[i++]=o++,e[i++]=o++,e[i++]=n++}for(a=0;a<3;a++)e[i++]=o++,e[i++]=o,e[i++]=n;return e}var B=new d,C=new c,H=new c;function U(e,i,o,r,n,a,s){let l=t.computeEllipsePositions({center:e,semiMajorAxis:i,semiMinorAxis:o,rotation:r,granularity:n},!1,!0).outerPositions,u=l.length/3,m=Array(u);for(let t=0;t<u;++t)m[t]=d.fromArray(l,3*t);let c=h.fromCartesianArray(m,a,s);return c.width>_.PI&&(c.north=c.north>0?_.PI_OVER_TWO-_.EPSILON7:c.north,c.south=c.south<0?_.EPSILON7-_.PI_OVER_TWO:c.south,c.east=_.PI,c.west=-_.PI),c}function Q(t){let e=(t=w(t,w.EMPTY_OBJECT)).center,i=w(t.ellipsoid,x.default),o=t.semiMajorAxis,n=t.semiMinorAxis,a=w(t.granularity,_.RADIANS_PER_DEGREE),s=w(t.vertexFormat,r.DEFAULT);if(N.defined("options.center",e),N.typeOf.number("options.semiMajorAxis",o),N.typeOf.number("options.semiMinorAxis",n),o<n)throw new b("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(a<=0)throw new b("granularity must be greater than zero.");let l=w(t.height,0),u=w(t.extrudedHeight,l);this._center=d.clone(e),this._semiMajorAxis=o,this._semiMinorAxis=n,this._ellipsoid=x.clone(i),this._rotation=w(t.rotation,0),this._stRotation=w(t.stRotation,0),this._height=Math.max(u,l),this._granularity=a,this._vertexFormat=r.clone(s),this._extrudedHeight=Math.min(u,l),this._shadowVolume=w(t.shadowVolume,!1),this._workerName="createEllipseGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0}Q.packedLength=d.packedLength+x.packedLength+r.packedLength+9,Q.pack=function(t,e,i){return N.defined("value",t),N.defined("array",e),i=w(i,0),d.pack(t._center,e,i),i+=d.packedLength,x.pack(t._ellipsoid,e,i),i+=x.packedLength,r.pack(t._vertexFormat,e,i),i+=r.packedLength,e[i++]=t._semiMajorAxis,e[i++]=t._semiMinorAxis,e[i++]=t._rotation,e[i++]=t._stRotation,e[i++]=t._height,e[i++]=t._granularity,e[i++]=t._extrudedHeight,e[i++]=+!!t._shadowVolume,e[i]=w(t._offsetAttribute,-1),e};var W=new d,J=new x,Z=new r,K={center:W,ellipsoid:J,vertexFormat:Z,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,stRotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};Q.unpack=function(t,e,i){N.defined("array",t),e=w(e,0);let o=d.unpack(t,e,W);e+=d.packedLength;let n=x.unpack(t,e,J);e+=x.packedLength;let a=r.unpack(t,e,Z);e+=r.packedLength;let s=t[e++],l=t[e++],u=t[e++],m=t[e++],c=t[e++],p=t[e++],h=t[e++],f=1===t[e++],A=t[e];return T(i)?(i._center=d.clone(o,i._center),i._ellipsoid=x.clone(n,i._ellipsoid),i._vertexFormat=r.clone(a,i._vertexFormat),i._semiMajorAxis=s,i._semiMinorAxis=l,i._rotation=u,i._stRotation=m,i._height=c,i._granularity=p,i._extrudedHeight=h,i._shadowVolume=f,i._offsetAttribute=-1===A?void 0:A,i):(K.height=c,K.extrudedHeight=h,K.granularity=p,K.stRotation=m,K.rotation=u,K.semiMajorAxis=s,K.semiMinorAxis=l,K.shadowVolume=f,K.offsetAttribute=-1===A?void 0:A,new Q(K))},Q.computeRectangle=function(t,e){let i=(t=w(t,w.EMPTY_OBJECT)).center,o=w(t.ellipsoid,x.default),r=t.semiMajorAxis,n=t.semiMinorAxis,a=w(t.granularity,_.RADIANS_PER_DEGREE),s=w(t.rotation,0);if(N.defined("options.center",i),N.typeOf.number("options.semiMajorAxis",r),N.typeOf.number("options.semiMinorAxis",n),r<n)throw new b("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(a<=0)throw new b("granularity must be greater than zero.");return U(i,r,n,s,a,o,e)},Q.createGeometry=function(r){if(r._semiMajorAxis<=0||r._semiMinorAxis<=0)return;let h=r._height,A=r._extrudedHeight,x=!_.equalsEpsilon(h,A,0,_.EPSILON2);r._center=r._ellipsoid.scaleToGeodeticSurface(r._center,r._center);let w={center:r._center,semiMajorAxis:r._semiMajorAxis,semiMinorAxis:r._semiMinorAxis,ellipsoid:r._ellipsoid,rotation:r._rotation,height:h,granularity:r._granularity,vertexFormat:r._vertexFormat,stRotation:r._stRotation},b;if(x)w.extrudedHeight=A,w.shadowVolume=r._shadowVolume,w.offsetAttribute=r._offsetAttribute,b=function(r){let h=r.center,A=r.ellipsoid,x=r.semiMajorAxis,_=d.multiplyByScalar(A.geodeticSurfaceNormal(h,I),r.height,I);C.center=d.add(h,_,C.center),C.radius=x,_=d.multiplyByScalar(A.geodeticSurfaceNormal(h,_),r.extrudedHeight,_),H.center=d.add(h,_,H.center),H.radius=x;let w=t.computeEllipsePositions(r,!0,!0),b=w.positions,N=w.numPts,F=w.outerPositions,B=c.union(C,H),U=G(b,r,!0),Q=Y(N),W=Q.length;Q.length=2*W;let J=b.length/3;for(let t=0;t<W;t+=3)Q[t+W]=Q[t+2]+J,Q[t+1+W]=Q[t+1]+J,Q[t+2+W]=Q[t]+J;let Z=new l({attributes:U,indices:n.createTypedArray(2*J/3,Q),primitiveType:s.TRIANGLES}),K=function(t,e){let i=e.vertexFormat,r=e.center,n=e.semiMajorAxis,s=e.semiMinorAxis,l=e.ellipsoid,c=e.height,h=e.extrudedHeight,A=e.stRotation,x=t.length/3*2,_=new Float64Array(3*x),w=i.st?new Float32Array(2*x):void 0,b=i.normal?new Float32Array(3*x):void 0,N=i.tangent?new Float32Array(3*x):void 0,F=i.bitangent?new Float32Array(3*x):void 0,G=e.shadowVolume,Y=G?new Float32Array(3*x):void 0,B=0,C=S,H=R,U=k,Q=new m(l),W=Q.project(l.cartesianToCartographic(r,L),D),J=l.scaleToGeodeticSurface(r,I);l.geodeticSurfaceNormal(J,J);let Z=p.fromAxisAngle(J,A,O),K=g.fromQuaternion(Z,j),q=y.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,V),X=y.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,z),$=t.length,tt=$/3*2;for(let e=0;e<$;e+=3){let o=e+1,r=e+2,a=d.fromArray(t,e,I),u;if(i.st){let t=g.multiplyByVector(K,a,E),e=Q.project(l.cartesianToCartographic(t,L),M);d.subtract(e,W,e),P.x=(e.x+n)/(2*n),P.y=(e.y+s)/(2*s),q.x=Math.min(P.x,q.x),q.y=Math.min(P.y,q.y),X.x=Math.max(P.x,X.x),X.y=Math.max(P.y,X.y),w[B+tt]=P.x,w[B+1+tt]=P.y,w[B++]=P.x,w[B++]=P.y}a=l.scaleToGeodeticSurface(a,a),u=d.clone(a,E),C=l.geodeticSurfaceNormal(a,C),G&&(Y[e+$]=-C.x,Y[o+$]=-C.y,Y[r+$]=-C.z);let m=d.multiplyByScalar(C,c,v);if(a=d.add(a,m,a),m=d.multiplyByScalar(C,h,m),u=d.add(u,m,u),i.position&&(_[e+$]=u.x,_[o+$]=u.y,_[r+$]=u.z,_[e]=a.x,_[o]=a.y,_[r]=a.z),i.normal||i.tangent||i.bitangent){U=d.clone(C,U);let n=d.fromArray(t,(e+3)%$,v);d.subtract(n,a,n);let s=d.subtract(u,a,M);C=d.normalize(d.cross(s,n,C),C),i.normal&&(b[e]=C.x,b[o]=C.y,b[r]=C.z,b[e+$]=C.x,b[o+$]=C.y,b[r+$]=C.z),i.tangent&&(H=d.normalize(d.cross(U,C,H),H),N[e]=H.x,N[o]=H.y,N[r]=H.z,N[e+$]=H.x,N[e+1+$]=H.y,N[e+2+$]=H.z),i.bitangent&&(F[e]=U.x,F[o]=U.y,F[r]=U.z,F[e+$]=U.x,F[o+$]=U.y,F[r+$]=U.z)}}if(i.st){$=w.length;for(let t=0;t<$;t+=2)w[t]=(w[t]-q.x)/(X.x-q.x),w[t+1]=(w[t+1]-q.y)/(X.y-q.y)}let te=new a;if(i.position&&(te.position=new u({componentDatatype:f.DOUBLE,componentsPerAttribute:3,values:_})),i.st&&(te.st=new u({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:w})),i.normal&&(te.normal=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:b})),i.tangent&&(te.tangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:N})),i.bitangent&&(te.bitangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:F})),G&&(te.extrudeDirection=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:Y})),T(e.offsetAttribute)){let t=new Uint8Array(x);if(e.offsetAttribute===o.TOP)t=t.fill(1,0,x/2);else{let i=+(e.offsetAttribute!==o.NONE);t=t.fill(i)}te.applyOffset=new u({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return te}(F,r);Q=function(t){let e=t.length/3,i=n.createTypedArray(e,6*e),o=0;for(let t=0;t<e;t++){let r=t,n=t+e,a=(r+1)%e,s=a+e;i[o++]=r,i[o++]=n,i[o++]=a,i[o++]=a,i[o++]=n,i[o++]=s}return i}(F);let q=new l({attributes:K,indices:n.createTypedArray(2*F.length/3,Q),primitiveType:s.TRIANGLES}),X=i.combineInstances([new e({geometry:Z}),new e({geometry:q})]);return{boundingSphere:B,attributes:X[0].attributes,indices:X[0].indices}}(w);else{let e,i,a,s,l,m,p;if(e=w.center,B=d.multiplyByScalar(w.ellipsoid.geodeticSurfaceNormal(e,B),w.height,B),i=new c(B=d.add(e,B,B),w.semiMajorAxis),s=(a=t.computeEllipsePositions(w,!0,!1)).positions,l=a.numPts,m=G(s,w,!1),p=Y(l),b={boundingSphere:i,attributes:m,indices:p=n.createTypedArray(s.length/3,p)},T(r._offsetAttribute)){let t=b.attributes.position.values.length,e=+(r._offsetAttribute!==o.NONE),i=new Uint8Array(t/3).fill(e);b.attributes.applyOffset=new u({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}}return new l({attributes:b.attributes,indices:b.indices,primitiveType:s.TRIANGLES,boundingSphere:b.boundingSphere,offsetAttribute:r._offsetAttribute})},Q.createShadowVolume=function(t,e,i){let o=t._granularity,n=t._ellipsoid,a=e(o,n),s=i(o,n);return new Q({center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:n,rotation:t._rotation,stRotation:t._stRotation,granularity:o,extrudedHeight:a,height:s,vertexFormat:r.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(Q.prototype,{rectangle:{get:function(){return T(this._rectangle)||(this._rectangle=U(this._center,this._semiMajorAxis,this._semiMinorAxis,this._rotation,this._granularity,this._ellipsoid)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return T(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(e){let i=-e._stRotation;if(0===i)return[0,0,0,1,1,0];let o=t.computeEllipsePositions({center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,rotation:e._rotation,granularity:e._granularity},!1,!0).outerPositions,r=o.length/3,n=Array(r);for(let t=0;t<r;++t)n[t]=d.fromArray(o,3*t);let a=e._ellipsoid,s=e.rectangle;return l._textureCoordinateRotationPoints(n,i,a,s)}(this)),this._textureCoordinateRotationPoints}}});var q=Q;export{q as a};