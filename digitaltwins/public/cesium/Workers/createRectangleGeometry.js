import{a as t}from"./chunk-IIL7G2BA.js";import{a as e}from"./chunk-KM43AUZL.js";import{a as n}from"./chunk-AOALMXNW.js";import"./chunk-CXNPIJLB.js";import"./chunk-APUOR5ZJ.js";import{a as o}from"./chunk-ZFTFDHK4.js";import{a as a}from"./chunk-74GQJJ7R.js";import{b as r}from"./chunk-CKMJZ5B3.js";import"./chunk-EEKB62LQ.js";import"./chunk-V3DSE3OK.js";import"./chunk-FMRIJYNG.js";import{a as i}from"./chunk-NNHN6WUY.js";import{a as s}from"./chunk-T7ERZ2CJ.js";import{b as l,c as u,d as c}from"./chunk-GSNDLQ4C.js";import{d as m}from"./chunk-BKSIEBAA.js";import{f as p,h as h,i as g}from"./chunk-YWRPWWKI.js";import{a as f}from"./chunk-VTVHUB7E.js";import{a as d,b as _,c as y,d as b,e as w}from"./chunk-JMSSU44E.js";import{a as A}from"./chunk-4UYSGV57.js";import"./chunk-ANLJ4KBN.js";import"./chunk-ID6SFQTL.js";import{a as v}from"./chunk-VLPNAR64.js";import{a as x,b as E}from"./chunk-GE5NEIZC.js";import{e as k}from"./chunk-35CVRQTC.js";var R=new d,F=new d,N=new d,L=new d,P=new h,T=new y,O=new m,D=new m;function j(t,e){let n=new u({attributes:new s,primitiveType:l.TRIANGLES});return n.attributes.position=new c({componentDatatype:f.DOUBLE,componentsPerAttribute:3,values:e.positions}),t.normal&&(n.attributes.normal=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:e.normals})),t.tangent&&(n.attributes.tangent=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:e.tangents})),t.bitangent&&(n.attributes.bitangent=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:e.bitangents})),n}var S=new d,I=new d;function M(e,n){let o=e._vertexFormat,a=e._ellipsoid,r=n.height,s=n.width,l=n.northCap,u=n.southCap,m=0,p=r,h=r,g=0;l&&(m=1,h-=1,g+=1),u&&(p-=1,h-=1,g+=1),g+=s*h;let _=o.position?new Float64Array(3*g):void 0,y=o.st?new Float32Array(2*g):void 0,b=0,A=0,v=Number.MAX_VALUE,x=Number.MAX_VALUE,E=-Number.MAX_VALUE,k=-Number.MAX_VALUE;for(let e=m;e<p;++e)for(let r=0;r<s;++r)t.computePosition(n,a,o.st,e,r,R,T),_[b++]=R.x,_[b++]=R.y,_[b++]=R.z,o.st&&(y[A++]=T.x,y[A++]=T.y,v=Math.min(v,T.x),x=Math.min(x,T.y),E=Math.max(E,T.x),k=Math.max(k,T.y));if(l&&(t.computePosition(n,a,o.st,0,0,R,T),_[b++]=R.x,_[b++]=R.y,_[b++]=R.z,o.st&&(y[A++]=T.x,y[A++]=T.y,v=T.x,x=T.y,E=T.x,k=T.y)),u&&(t.computePosition(n,a,o.st,r-1,0,R,T),_[b++]=R.x,_[b++]=R.y,_[b]=R.z,o.st&&(y[A++]=T.x,y[A]=T.y,v=Math.min(v,T.x),x=Math.min(x,T.y),E=Math.max(E,T.x),k=Math.max(k,T.y))),o.st&&(v<0||x<0||E>1||k>1))for(let t=0;t<y.length;t+=2)y[t]=(y[t]-v)/(E-v),y[t+1]=(y[t+1]-x)/(k-x);let P=function(t,e,n,o){let a=t.length,r=e.normal?new Float32Array(a):void 0,i=e.tangent?new Float32Array(a):void 0,s=e.bitangent?new Float32Array(a):void 0,l=0,u=F;if(e.normal||e.tangent||e.bitangent)for(let c=0;c<a;c+=3){let a=d.fromArray(t,c,R),m=l+1,p=l+2;u=n.geodeticSurfaceNormal(a,u),(e.tangent||e.bitangent)&&(d.cross(d.UNIT_Z,u,N),w.multiplyByVector(o,N,N),d.normalize(N,N),e.bitangent&&d.normalize(d.cross(u,N,L),L)),e.normal&&(r[l]=u.x,r[m]=u.y,r[p]=u.z),e.tangent&&(i[l]=N.x,i[m]=N.y,i[p]=N.z),e.bitangent&&(s[l]=L.x,s[m]=L.y,s[p]=L.z),l+=3}return j(e,{positions:t,normals:r,tangents:i,bitangents:s})}(_,o,a,n.tangentRotationMatrix),O=6*(s-1)*(h-1);l&&(O+=3*(s-1)),u&&(O+=3*(s-1));let D=i.createTypedArray(g,O),S=0,I=0,M;for(M=0;M<h-1;++M){for(let t=0;t<s-1;++t){let t=S,e=t+s,n=e+1,o=t+1;D[I++]=t,D[I++]=e,D[I++]=o,D[I++]=o,D[I++]=e,D[I++]=n,++S}++S}if(l||u){let t,e,n=g-1,o=g-1;if(l&&u&&(n=g-2),S=0,l)for(M=0;M<s-1;M++)e=(t=S)+1,D[I++]=n,D[I++]=t,D[I++]=e,++S;if(u)for(S=(h-1)*s,M=0;M<s-1;M++)e=(t=S)+1,D[I++]=t,D[I++]=o,D[I++]=e,++S}return P.indices=D,o.st&&(P.attributes.st=new c({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:y})),P}function H(t,e,n,o,a){return t[e++]=o[n],t[e++]=o[n+1],t[e++]=o[n+2],t[e++]=a[n],t[e++]=a[n+1],t[e]=a[n+2],t}function V(t,e,n,o){return t[e++]=o[n],t[e++]=o[n+1],t[e++]=o[n],t[e]=o[n+1],t}var C=new a,U=[new d,new d,new d,new d],G=new _,z=new _;function B(e,n,o,a,r){if(0===o)return h.clone(e,r);let i=t.computeOptions(e,n,o,0,P,G),s=i.height,l=i.width;return t.computePosition(i,a,!1,0,0,U[0]),t.computePosition(i,a,!1,0,l-1,U[1]),t.computePosition(i,a,!1,s-1,0,U[2]),t.computePosition(i,a,!1,s-1,l-1,U[3]),h.fromCartesianArray(U,a,r)}function Y(t){let e=(t=v(t,v.EMPTY_OBJECT)).rectangle;if(E.typeOf.object("rectangle",e),h._validate(e),e.north<e.south)throw new x("options.rectangle.north must be greater than or equal to options.rectangle.south");let n=v(t.height,0),o=v(t.extrudedHeight,n);this._rectangle=h.clone(e),this._granularity=v(t.granularity,A.RADIANS_PER_DEGREE),this._ellipsoid=b.clone(v(t.ellipsoid,b.default)),this._surfaceHeight=Math.max(n,o),this._rotation=v(t.rotation,0),this._stRotation=v(t.stRotation,0),this._vertexFormat=a.clone(v(t.vertexFormat,a.DEFAULT)),this._extrudedHeight=Math.min(n,o),this._shadowVolume=v(t.shadowVolume,!1),this._workerName="createRectangleGeometry",this._offsetAttribute=t.offsetAttribute,this._rotatedRectangle=void 0,this._textureCoordinateRotationPoints=void 0}Y.packedLength=h.packedLength+b.packedLength+a.packedLength+7,Y.pack=function(t,e,n){return E.typeOf.object("value",t),E.defined("array",e),n=v(n,0),h.pack(t._rectangle,e,n),n+=h.packedLength,b.pack(t._ellipsoid,e,n),n+=b.packedLength,a.pack(t._vertexFormat,e,n),n+=a.packedLength,e[n++]=t._granularity,e[n++]=t._surfaceHeight,e[n++]=t._rotation,e[n++]=t._stRotation,e[n++]=t._extrudedHeight,e[n++]=+!!t._shadowVolume,e[n]=v(t._offsetAttribute,-1),e};var J=new h,K=b.clone(b.UNIT_SPHERE),q={rectangle:J,ellipsoid:K,vertexFormat:C,granularity:void 0,height:void 0,rotation:void 0,stRotation:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};Y.unpack=function(t,e,n){E.defined("array",t),e=v(e,0);let o=h.unpack(t,e,J);e+=h.packedLength;let r=b.unpack(t,e,K);e+=b.packedLength;let i=a.unpack(t,e,C);e+=a.packedLength;let s=t[e++],l=t[e++],u=t[e++],c=t[e++],m=t[e++],p=1===t[e++],g=t[e];return k(n)?(n._rectangle=h.clone(o,n._rectangle),n._ellipsoid=b.clone(r,n._ellipsoid),n._vertexFormat=a.clone(i,n._vertexFormat),n._granularity=s,n._surfaceHeight=l,n._rotation=u,n._stRotation=c,n._extrudedHeight=m,n._shadowVolume=p,n._offsetAttribute=-1===g?void 0:g,n):(q.granularity=s,q.height=l,q.rotation=u,q.stRotation=c,q.extrudedHeight=m,q.shadowVolume=p,q.offsetAttribute=-1===g?void 0:g,new Y(q))},Y.computeRectangle=function(t,e){let n=(t=v(t,v.EMPTY_OBJECT)).rectangle;if(E.typeOf.object("rectangle",n),h._validate(n),n.north<n.south)throw new x("options.rectangle.north must be greater than or equal to options.rectangle.south");let o=v(t.granularity,A.RADIANS_PER_DEGREE),a=v(t.ellipsoid,b.default);return B(n,o,v(t.rotation,0),a,e)};var Z=new w,Q=new p,X=new _;Y.createGeometry=function(s){let l,g;if(A.equalsEpsilon(s._rectangle.north,s._rectangle.south,A.EPSILON10)||A.equalsEpsilon(s._rectangle.east,s._rectangle.west,A.EPSILON10))return;let _=s._rectangle,y=s._ellipsoid,b=s._rotation,v=s._stRotation,x=s._vertexFormat,E=t.computeOptions(_,s._granularity,b,v,P,G,z);if(0!==v||0!==b){let t=h.center(_,X),e=y.geodeticSurfaceNormalCartographic(t,S);p.fromAxisAngle(e,-v,Q),w.fromQuaternion(Q,Z)}else w.clone(w.IDENTITY,Z);let T=s._surfaceHeight,U=s._extrudedHeight,B=!A.equalsEpsilon(T,U,0,A.EPSILON2);if(E.lonScalar=1/s._rectangle.width,E.latScalar=1/s._rectangle.height,E.tangentRotationMatrix=Z,_=s._rectangle,B){l=function(t,s){let l=t._shadowVolume,u=t._offsetAttribute,m=t._vertexFormat,p=t._extrudedHeight,h=t._surfaceHeight,g=t._ellipsoid,_=s.height,y=s.width,b;if(l){let e=a.clone(m,C);e.normal=!0,t._vertexFormat=e}let w=M(t,s);l&&(t._vertexFormat=m);let v=r.scaleToGeodeticHeight(w.attributes.position.values,h,g,!1),x=(v=new Float64Array(v)).length,E=2*x,P=new Float64Array(E);P.set(v);let T=r.scaleToGeodeticHeight(w.attributes.position.values,p,g);P.set(T,x),w.attributes.position.values=P;let O=m.normal?new Float32Array(E):void 0,D=m.tangent?new Float32Array(E):void 0,U=m.bitangent?new Float32Array(E):void 0,G=m.st?new Float32Array(E/3*2):void 0,z,B;if(m.normal){for(B=w.attributes.normal.values,O.set(B),b=0;b<x;b++)B[b]=-B[b];O.set(B,x),w.attributes.normal.values=O}if(l){B=w.attributes.normal.values,m.normal||(w.attributes.normal=void 0);let t=new Float32Array(E);for(b=0;b<x;b++)B[b]=-B[b];t.set(B,x),w.attributes.extrudeDirection=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:t})}let Y,J=k(u);if(J){let t=x/3*2,e=new Uint8Array(t);u===o.TOP?e=e.fill(1,0,t/2):(Y=+(u!==o.NONE),e=e.fill(Y)),w.attributes.applyOffset=new c({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}if(m.tangent){let t=w.attributes.tangent.values;for(D.set(t),b=0;b<x;b++)t[b]=-t[b];D.set(t,x),w.attributes.tangent.values=D}if(m.bitangent){let t=w.attributes.bitangent.values;U.set(t),U.set(t,x),w.attributes.bitangent.values=U}m.st&&(z=w.attributes.st.values,G.set(z),G.set(z,x/3*2),w.attributes.st.values=G);let K=w.indices,q=K.length,Z=x/3,Q=i.createTypedArray(E/3,2*q);for(Q.set(K),b=0;b<q;b+=3)Q[b+q]=K[b+2]+Z,Q[b+1+q]=K[b+1]+Z,Q[b+2+q]=K[b]+Z;w.indices=Q;let X=s.northCap,W=s.southCap,$=_,tt=2,te=0,tn=4,to=4;X&&(tt-=1,$-=1,te+=1,tn-=2,to-=1),W&&(tt-=1,$-=1,te+=1,tn-=2,to-=1);let ta=((te+=tt*y+2*$-tn)+to)*2,tr=new Float64Array(3*ta),ti=l?new Float32Array(3*ta):void 0,ts=J?new Uint8Array(ta):void 0,tl=m.st?new Float32Array(2*ta):void 0,tu=u===o.TOP;J&&!tu&&(Y=+(u===o.ALL),ts=ts.fill(Y));let tc=0,tm=0,tp=0,th=0,tg=y*$,tf;for(b=0;b<tg;b+=y)tr=H(tr,tc,tf=3*b,v,T),tc+=6,m.st&&(tl=V(tl,tm,2*b,z),tm+=4),l&&(tp+=3,ti[tp++]=B[tf],ti[tp++]=B[tf+1],ti[tp++]=B[tf+2]),tu&&(ts[th++]=1,th+=1);if(W){let t=X?tg+1:tg;for(tf=3*t,b=0;b<2;b++)tr=H(tr,tc,tf,v,T),tc+=6,m.st&&(tl=V(tl,tm,2*t,z),tm+=4),l&&(tp+=3,ti[tp++]=B[tf],ti[tp++]=B[tf+1],ti[tp++]=B[tf+2]),tu&&(ts[th++]=1,th+=1)}else for(b=tg-y;b<tg;b++)tr=H(tr,tc,tf=3*b,v,T),tc+=6,m.st&&(tl=V(tl,tm,2*b,z),tm+=4),l&&(tp+=3,ti[tp++]=B[tf],ti[tp++]=B[tf+1],ti[tp++]=B[tf+2]),tu&&(ts[th++]=1,th+=1);for(b=tg-1;b>0;b-=y)tr=H(tr,tc,tf=3*b,v,T),tc+=6,m.st&&(tl=V(tl,tm,2*b,z),tm+=4),l&&(tp+=3,ti[tp++]=B[tf],ti[tp++]=B[tf+1],ti[tp++]=B[tf+2]),tu&&(ts[th++]=1,th+=1);if(X)for(tf=3*tg,b=0;b<2;b++)tr=H(tr,tc,tf,v,T),tc+=6,m.st&&(tl=V(tl,tm,2*tg,z),tm+=4),l&&(tp+=3,ti[tp++]=B[tf],ti[tp++]=B[tf+1],ti[tp++]=B[tf+2]),tu&&(ts[th++]=1,th+=1);else for(b=y-1;b>=0;b--)tr=H(tr,tc,tf=3*b,v,T),tc+=6,m.st&&(tl=V(tl,tm,2*b,z),tm+=4),l&&(tp+=3,ti[tp++]=B[tf],ti[tp++]=B[tf+1],ti[tp++]=B[tf+2]),tu&&(ts[th++]=1,th+=1);let td=function(t,e,n){let o=t.length,a=e.normal?new Float32Array(o):void 0,r=e.tangent?new Float32Array(o):void 0,i=e.bitangent?new Float32Array(o):void 0,s=0,l=0,u=0,c=!0,m=L,p=N,h=F;if(e.normal||e.tangent||e.bitangent)for(let g=0;g<o;g+=6){let f=d.fromArray(t,g,R),_=d.fromArray(t,(g+6)%o,S);if(c){let e=d.fromArray(t,(g+3)%o,I);d.subtract(_,f,_),d.subtract(e,f,e),h=d.normalize(d.cross(e,_,h),h),c=!1}d.equalsEpsilon(_,f,A.EPSILON10)&&(c=!0),(e.tangent||e.bitangent)&&(m=n.geodeticSurfaceNormal(f,m),e.tangent&&(p=d.normalize(d.cross(m,h,p),p))),e.normal&&(a[s++]=h.x,a[s++]=h.y,a[s++]=h.z,a[s++]=h.x,a[s++]=h.y,a[s++]=h.z),e.tangent&&(r[l++]=p.x,r[l++]=p.y,r[l++]=p.z,r[l++]=p.x,r[l++]=p.y,r[l++]=p.z),e.bitangent&&(i[u++]=m.x,i[u++]=m.y,i[u++]=m.z,i[u++]=m.x,i[u++]=m.y,i[u++]=m.z)}return j(e,{positions:t,normals:a,tangents:r,bitangents:i})}(tr,m,g);m.st&&(td.attributes.st=new c({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:tl})),l&&(td.attributes.extrudeDirection=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:ti})),J&&(td.attributes.applyOffset=new c({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:ts}));let t_=i.createTypedArray(ta,6*te),ty,tb,tw,tA;x=tr.length/3;let tv=0;for(b=0;b<x-1;b+=2){tA=((ty=b)+2)%x;let t=d.fromArray(tr,3*ty,S),e=d.fromArray(tr,3*tA,I);d.equalsEpsilon(t,e,A.EPSILON10)||(tw=((tb=(ty+1)%x)+2)%x,t_[tv++]=ty,t_[tv++]=tb,t_[tv++]=tA,t_[tv++]=tA,t_[tv++]=tb,t_[tv++]=tw)}return td.indices=t_,(td=n.combineInstances([new e({geometry:w}),new e({geometry:td})]))[0]}(s,E);let t=m.fromRectangle3D(_,y,T,D),u=m.fromRectangle3D(_,y,U,O);g=m.union(t,u)}else{if((l=M(s,E)).attributes.position.values=r.scaleToGeodeticHeight(l.attributes.position.values,T,y,!1),k(s._offsetAttribute)){let t=l.attributes.position.values.length,e=+(s._offsetAttribute!==o.NONE),n=new Uint8Array(t/3).fill(e);l.attributes.applyOffset=new c({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}g=m.fromRectangle3D(_,y,T)}return x.position||delete l.attributes.position,new u({attributes:l.attributes,indices:l.indices,primitiveType:l.primitiveType,boundingSphere:g,offsetAttribute:s._offsetAttribute})},Y.createShadowVolume=function(t,e,n){let o=t._granularity,r=t._ellipsoid,i=e(o,r),s=n(o,r);return new Y({rectangle:t._rectangle,rotation:t._rotation,ellipsoid:r,stRotation:t._stRotation,granularity:o,extrudedHeight:s,height:i,vertexFormat:a.POSITION_ONLY,shadowVolume:!0})};var W=new h,$=[new y,new y,new y],tt=new g,te=new _;Object.defineProperties(Y.prototype,{rectangle:{get:function(){return k(this._rotatedRectangle)||(this._rotatedRectangle=B(this._rectangle,this._granularity,this._rotation,this._ellipsoid)),this._rotatedRectangle}},textureCoordinateRotationPoints:{get:function(){return k(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){if(0===t._stRotation)return[0,0,0,1,1,0];let e=h.clone(t._rectangle,W),n=t._granularity,o=t._ellipsoid,a=B(e,n,t._rotation-t._stRotation,o,W);$[0].x=a.west,$[0].y=a.south,$[1].x=a.west,$[1].y=a.north,$[2].x=a.east,$[2].y=a.south;let r=t.rectangle,i=g.fromRotation(t._stRotation,tt),s=h.center(r,te);for(let t=0;t<3;++t){let e=$[t];e.x-=s.longitude,e.y-=s.latitude,g.multiplyByVector(i,e,e),e.x+=s.longitude,e.y+=s.latitude,e.x=(e.x-r.west)/r.width,e.y=(e.y-r.south)/r.height}let l=$[0],u=$[1],c=$[2],m=Array(6);return y.pack(l,m),y.pack(u,m,2),y.pack(c,m,4),m}(this)),this._textureCoordinateRotationPoints}}});var tn=function(t,e){return k(e)&&(t=Y.unpack(t,e)),t._ellipsoid=b.clone(t._ellipsoid),t._rectangle=h.clone(t._rectangle),Y.createGeometry(t)};export{tn as default};