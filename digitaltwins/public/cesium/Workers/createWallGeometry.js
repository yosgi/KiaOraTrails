import{a as t}from"./chunk-II4JDBXY.js";import"./chunk-M5SITFFN.js";import"./chunk-ZPYKVVFF.js";import{a as e}from"./chunk-74GQJJ7R.js";import"./chunk-WNTCOVG2.js";import"./chunk-EEKB62LQ.js";import"./chunk-V3DSE3OK.js";import"./chunk-FMRIJYNG.js";import{a as i}from"./chunk-NNHN6WUY.js";import{a as n}from"./chunk-T7ERZ2CJ.js";import{b as o,c as r,d as a}from"./chunk-GSNDLQ4C.js";import{d as s}from"./chunk-BKSIEBAA.js";import"./chunk-YWRPWWKI.js";import{a as m}from"./chunk-VTVHUB7E.js";import{a as l,d as p}from"./chunk-JMSSU44E.js";import{a as u}from"./chunk-4UYSGV57.js";import"./chunk-ANLJ4KBN.js";import"./chunk-ID6SFQTL.js";import{a as h}from"./chunk-VLPNAR64.js";import{a as c}from"./chunk-GE5NEIZC.js";import{e as g}from"./chunk-35CVRQTC.js";var f=new l,d=new l,y=new l,k=new l,w=new l,_=new l,A=new l;function v(t){let i=(t=h(t,h.EMPTY_OBJECT)).positions,n=t.maximumHeights,o=t.minimumHeights;if(!g(i))throw new c("options.positions is required.");if(g(n)&&n.length!==i.length)throw new c("options.positions and options.maximumHeights must have the same length.");if(g(o)&&o.length!==i.length)throw new c("options.positions and options.minimumHeights must have the same length.");let r=h(t.vertexFormat,e.DEFAULT),a=h(t.granularity,u.RADIANS_PER_DEGREE),s=h(t.ellipsoid,p.default);this._positions=i,this._minimumHeights=o,this._maximumHeights=n,this._vertexFormat=e.clone(r),this._granularity=a,this._ellipsoid=p.clone(s),this._workerName="createWallGeometry";let m=1+i.length*l.packedLength+2;g(o)&&(m+=o.length),g(n)&&(m+=n.length),this.packedLength=m+p.packedLength+e.packedLength+1}v.pack=function(t,i,n){if(!g(t))throw new c("value is required");if(!g(i))throw new c("array is required");n=h(n,0);let o,r=t._positions,a=r.length;for(i[n++]=a,o=0;o<a;++o,n+=l.packedLength)l.pack(r[o],i,n);let s=t._minimumHeights;if(a=g(s)?s.length:0,i[n++]=a,g(s))for(o=0;o<a;++o)i[n++]=s[o];let m=t._maximumHeights;if(a=g(m)?m.length:0,i[n++]=a,g(m))for(o=0;o<a;++o)i[n++]=m[o];return p.pack(t._ellipsoid,i,n),n+=p.packedLength,e.pack(t._vertexFormat,i,n),i[n+=e.packedLength]=t._granularity,i};var x=p.clone(p.UNIT_SPHERE),E=new e,F={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:x,vertexFormat:E,granularity:void 0};v.unpack=function(t,i,n){let o,r;if(!g(t))throw new c("array is required");i=h(i,0);let a,s=t[i++],m=Array(s);for(a=0;a<s;++a,i+=l.packedLength)m[a]=l.unpack(t,i);if((s=t[i++])>0)for(o=Array(s),a=0;a<s;++a)o[a]=t[i++];if((s=t[i++])>0)for(r=Array(s),a=0;a<s;++a)r[a]=t[i++];let u=p.unpack(t,i,x);i+=p.packedLength;let f=e.unpack(t,i,E),d=t[i+=e.packedLength];return g(n)?(n._positions=m,n._minimumHeights=o,n._maximumHeights=r,n._ellipsoid=p.clone(u,n._ellipsoid),n._vertexFormat=e.clone(f,n._vertexFormat),n._granularity=d,n):(F.positions=m,F.minimumHeights=o,F.maximumHeights=r,F.granularity=d,new v(F))},v.fromConstantHeights=function(t){let e=(t=h(t,h.EMPTY_OBJECT)).positions;if(!g(e))throw new c("options.positions is required.");let i,n,o=t.minimumHeight,r=t.maximumHeight,a=g(o),s=g(r);if(a||s){let t=e.length;i=a?Array(t):void 0,n=s?Array(t):void 0;for(let e=0;e<t;++e)a&&(i[e]=o),s&&(n[e]=r)}return new v({positions:e,maximumHeights:n,minimumHeights:i,ellipsoid:t.ellipsoid,vertexFormat:t.vertexFormat})},v.createGeometry=function(e){let p=e._positions,h=e._minimumHeights,c=e._maximumHeights,v=e._vertexFormat,x=e._granularity,E=e._ellipsoid,F=t.computePositions(E,p,c,h,x,!0);if(!g(F))return;let H=F.bottomPositions,L=F.topPositions,j=F.numCorners,b=L.length,T=2*b,N=v.position?new Float64Array(T):void 0,P=v.normal?new Float32Array(T):void 0,S=v.tangent?new Float32Array(T):void 0,D=v.bitangent?new Float32Array(T):void 0,I=v.st?new Float32Array(T/3*2):void 0,O=0,R=0,z=0,G=0,C=0,V=A,B=_,J=w,Y=!0,q,U=0,K=1/((b/=3)-j-1);for(q=0;q<b;++q){let t=3*q,e=l.fromArray(L,t,f),i=l.fromArray(H,t,d);if(v.position&&(N[O++]=i.x,N[O++]=i.y,N[O++]=i.z,N[O++]=e.x,N[O++]=e.y,N[O++]=e.z),v.st&&(I[C++]=U,I[C++]=0,I[C++]=U,I[C++]=1),v.normal||v.tangent||v.bitangent){let i=l.clone(l.ZERO,k),n=l.subtract(e,E.geodeticSurfaceNormal(e,d),d);if(q+1<b&&(i=l.fromArray(L,t+3,k)),Y){let t=l.subtract(i,e,y),o=l.subtract(n,e,f);V=l.normalize(l.cross(o,t,V),V),Y=!1}l.equalsEpsilon(e,i,u.EPSILON10)?Y=!0:(U+=K,v.tangent&&(B=l.normalize(l.subtract(i,e,B),B)),v.bitangent&&(J=l.normalize(l.cross(V,B,J),J))),v.normal&&(P[R++]=V.x,P[R++]=V.y,P[R++]=V.z,P[R++]=V.x,P[R++]=V.y,P[R++]=V.z),v.tangent&&(S[G++]=B.x,S[G++]=B.y,S[G++]=B.z,S[G++]=B.x,S[G++]=B.y,S[G++]=B.z),v.bitangent&&(D[z++]=J.x,D[z++]=J.y,D[z++]=J.z,D[z++]=J.x,D[z++]=J.y,D[z++]=J.z)}}let W=new n;v.position&&(W.position=new a({componentDatatype:m.DOUBLE,componentsPerAttribute:3,values:N})),v.normal&&(W.normal=new a({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:P})),v.tangent&&(W.tangent=new a({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:S})),v.bitangent&&(W.bitangent=new a({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:D})),v.st&&(W.st=new a({componentDatatype:m.FLOAT,componentsPerAttribute:2,values:I}));let M=T/3;T-=6*(j+1);let Q=i.createTypedArray(M,T),Z=0;for(q=0;q<M-2;q+=2){let t=q,e=q+2,i=l.fromArray(N,3*t,f),n=l.fromArray(N,3*e,d);if(l.equalsEpsilon(i,n,u.EPSILON10))continue;let o=q+1,r=q+3;Q[Z++]=o,Q[Z++]=t,Q[Z++]=r,Q[Z++]=r,Q[Z++]=t,Q[Z++]=e}return new r({attributes:W,indices:Q,primitiveType:o.TRIANGLES,boundingSphere:new s.fromVertices(N)})};var H=function(t,e){return g(e)&&(t=v.unpack(t,e)),t._ellipsoid=p.clone(t._ellipsoid),v.createGeometry(t)};export{H as default};