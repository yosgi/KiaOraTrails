import{a as r}from"./chunk-4UYSGV57.js";import{a as e}from"./chunk-ANLJ4KBN.js";import{a as t}from"./chunk-GE5NEIZC.js";import{e as n}from"./chunk-35CVRQTC.js";var a={UNSIGNED_BYTE:e.UNSIGNED_BYTE,UNSIGNED_SHORT:e.UNSIGNED_SHORT,UNSIGNED_INT:e.UNSIGNED_INT};a.getSizeInBytes=function(r){switch(r){case a.UNSIGNED_BYTE:return Uint8Array.BYTES_PER_ELEMENT;case a.UNSIGNED_SHORT:return Uint16Array.BYTES_PER_ELEMENT;case a.UNSIGNED_INT:return Uint32Array.BYTES_PER_ELEMENT}throw new t("indexDatatype is required and must be a valid IndexDatatype constant.")},a.fromSizeInBytes=function(r){switch(r){case 2:return a.UNSIGNED_SHORT;case 4:return a.UNSIGNED_INT;case 1:return a.UNSIGNED_BYTE;default:throw new t("Size in bytes cannot be mapped to an IndexDatatype")}},a.validate=function(r){return n(r)&&(r===a.UNSIGNED_BYTE||r===a.UNSIGNED_SHORT||r===a.UNSIGNED_INT)},a.createTypedArray=function(e,a){if(!n(e))throw new t("numberOfVertices is required.");return e>=r.SIXTY_FOUR_KILOBYTES?new Uint32Array(a):new Uint16Array(a)},a.createTypedArrayFromArrayBuffer=function(e,a,i,N){if(!n(e))throw new t("numberOfVertices is required.");if(!n(a))throw new t("sourceArray is required.");if(!n(i))throw new t("byteOffset is required.");return e>=r.SIXTY_FOUR_KILOBYTES?new Uint32Array(a,i,N):new Uint16Array(a,i,N)},a.fromTypedArray=function(r){if(r instanceof Uint8Array)return a.UNSIGNED_BYTE;if(r instanceof Uint16Array)return a.UNSIGNED_SHORT;if(r instanceof Uint32Array)return a.UNSIGNED_INT;throw new t("array must be a Uint8Array, Uint16Array, or Uint32Array.")};var i=Object.freeze(a);export{i as a};