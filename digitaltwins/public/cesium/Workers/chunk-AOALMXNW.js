import{a as e}from"./chunk-CXNPIJLB.js";import{a as t}from"./chunk-APUOR5ZJ.js";import{b as r}from"./chunk-V3DSE3OK.js";import{a as i}from"./chunk-FMRIJYNG.js";import{a as n}from"./chunk-NNHN6WUY.js";import{a as o,b as s,c as a,d as u}from"./chunk-GSNDLQ4C.js";import{a as l,b as p,d as c}from"./chunk-BKSIEBAA.js";import{a as m,b as f}from"./chunk-YWRPWWKI.js";import{a as y}from"./chunk-VTVHUB7E.js";import{a as h,b as d,c as v,e as b}from"./chunk-JMSSU44E.js";import{a as w}from"./chunk-4UYSGV57.js";import{a as g}from"./chunk-VLPNAR64.js";import{a as T,b as A}from"./chunk-GE5NEIZC.js";import{e as S}from"./chunk-35CVRQTC.js";var N=new h,x=new h,P=new h,E=function(e,t,r,i,n){let o,s,a,u,l,p,c,m;if(A.defined("point",e),A.defined("p0",t),A.defined("p1",r),A.defined("p2",i),S(n)||(n=new h),S(t.z)){if(h.equalsEpsilon(e,t,w.EPSILON14))return h.clone(h.UNIT_X,n);if(h.equalsEpsilon(e,r,w.EPSILON14))return h.clone(h.UNIT_Y,n);if(h.equalsEpsilon(e,i,w.EPSILON14))return h.clone(h.UNIT_Z,n);o=h.subtract(r,t,N),s=h.subtract(i,t,x),a=h.subtract(e,t,P),u=h.dot(o,o),l=h.dot(o,s),p=h.dot(o,a),c=h.dot(s,s),m=h.dot(s,a)}else{if(v.equalsEpsilon(e,t,w.EPSILON14))return h.clone(h.UNIT_X,n);if(v.equalsEpsilon(e,r,w.EPSILON14))return h.clone(h.UNIT_Y,n);if(v.equalsEpsilon(e,i,w.EPSILON14))return h.clone(h.UNIT_Z,n);o=v.subtract(r,t,N),s=v.subtract(i,t,x),a=v.subtract(e,t,P),u=v.dot(o,o),l=v.dot(o,s),p=v.dot(o,a),c=v.dot(s,s),m=v.dot(s,a)}n.y=c*p-l*m,n.z=u*m-l*p;let f=u*c-l*l;if(0!==f)return n.y/=f,n.z/=f,n.x=1-n.y-n.z,n},I={};I.calculateACMR=function(e){let t=(e=g(e,g.EMPTY_OBJECT)).indices,r=e.maximumIndex,i=g(e.cacheSize,24);if(!S(t))throw new T("indices is required.");let n=t.length;if(n<3||n%3!=0)throw new T("indices length must be a multiple of three.");if(r<=0)throw new T("maximumIndex must be greater than zero.");if(i<3)throw new T("cacheSize must be greater than two.");if(!S(r)){r=0;let e=0,i=t[0];for(;e<n;)i>r&&(r=i),i=t[++e]}let o=[];for(let e=0;e<r+1;e++)o[e]=0;let s=i+1;for(let e=0;e<n;++e)s-o[t[e]]>i&&(o[t[e]]=s,++s);return(s-i+1)/(n/3)},I.tipsify=function(e){let t,r;let i=(e=g(e,g.EMPTY_OBJECT)).indices,n=e.maximumIndex,o=g(e.cacheSize,24),s;if(!S(i))throw new T("indices is required.");let a=i.length;if(a<3||a%3!=0)throw new T("indices length must be a multiple of three.");if(n<=0)throw new T("maximumIndex must be greater than zero.");if(o<3)throw new T("cacheSize must be greater than two.");let u=0,l=0,p=i[0];if(S(n))u=n+1;else{for(;l<a;)p>u&&(u=p),p=i[++l];if(-1===u)return 0;++u}let c=[],m;for(m=0;m<u;m++)c[m]={numLiveTriangles:0,timeStamp:0,vertexTriangles:[]};l=0;let f=0;for(;l<a;)c[i[l]].vertexTriangles.push(f),++c[i[l]].numLiveTriangles,c[i[l+1]].vertexTriangles.push(f),++c[i[l+1]].numLiveTriangles,c[i[l+2]].vertexTriangles.push(f),++c[i[l+2]].numLiveTriangles,++f,l+=3;let y=0,h=o+1;s=1;let d=[],v=[],b,w,A=0,N=[],x=a/3,P=[];for(m=0;m<x;m++)P[m]=!1;for(;-1!==y;){d=[],r=(w=c[y]).vertexTriangles.length;for(let e=0;e<r;++e)if(!P[f=w.vertexTriangles[e]]){P[f]=!0,l=f+f+f;for(let e=0;e<3;++e)t=i[l],d.push(t),v.push(t),N[A]=t,++A,b=c[t],--b.numLiveTriangles,h-b.timeStamp>o&&(b.timeStamp=h,++h),++l}y=function(e,t,r,i,n,o,a){let u=-1,l,p=-1,c=0;for(;c<r.length;){let e=r[c];i[e].numLiveTriangles&&(l=0,n-i[e].timeStamp+2*i[e].numLiveTriangles<=t&&(l=n-i[e].timeStamp),(l>p||-1===p)&&(p=l,u=e)),++c}return -1===u?function(e,t,r,i){for(;t.length>=1;){let r=t[t.length-1];if(t.splice(t.length-1,1),e[r].numLiveTriangles>0)return r}for(;s<i;){if(e[s].numLiveTriangles>0)return++s-1;++s}return -1}(i,o,0,a):u}(0,o,d,c,h,v,u)}return N};var O={};function L(e,t,r,i,n){e[t++]=r,e[t++]=i,e[t++]=i,e[t++]=n,e[t++]=n,e[t]=r}function z(e){let t={};for(let r in e)if(e.hasOwnProperty(r)&&S(e[r])&&S(e[r].values)){let i=e[r];t[r]=new u({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return t}O.toWireframe=function(e){if(!S(e))throw new T("geometry is required.");let t=e.indices;if(S(t)){switch(e.primitiveType){case s.TRIANGLES:e.indices=function(e){let t=e.length,r=n.createTypedArray(t,t/3*6),i=0;for(let n=0;n<t;n+=3,i+=6)L(r,i,e[n],e[n+1],e[n+2]);return r}(t);break;case s.TRIANGLE_STRIP:e.indices=function(e){let t=e.length;if(t>=3){let r=n.createTypedArray(t,(t-2)*6);L(r,0,e[0],e[1],e[2]);let i=6;for(let n=3;n<t;++n,i+=6)L(r,i,e[n-1],e[n],e[n-2]);return r}return new Uint16Array}(t);break;case s.TRIANGLE_FAN:e.indices=function(e){if(e.length>0){let t=e.length-1,r=n.createTypedArray(t,(t-1)*6),i=e[0],o=0;for(let n=1;n<t;++n,o+=6)L(r,o,i,e[n],e[n+1]);return r}return new Uint16Array}(t);break;default:throw new T("geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.")}e.primitiveType=s.LINES}return e},O.createLineSegmentsForVectors=function(e,t,r){if(t=g(t,"normal"),!S(e))throw new T("geometry is required.");if(!S(e.attributes.position))throw new T("geometry.attributes.position is required.");if(!S(e.attributes[t]))throw new T(`geometry.attributes must have an attribute with the same name as the attributeName parameter, ${t}.`);r=g(r,1e4);let i=e.attributes.position.values,n=e.attributes[t].values,o=i.length,l=new Float64Array(2*o),p=0;for(let e=0;e<o;e+=3)l[p++]=i[e],l[p++]=i[e+1],l[p++]=i[e+2],l[p++]=i[e]+n[e]*r,l[p++]=i[e+1]+n[e+1]*r,l[p++]=i[e+2]+n[e+2]*r;let m,f=e.boundingSphere;return S(f)&&(m=new c(f.center,f.radius+r)),new a({attributes:{position:new u({componentDatatype:y.DOUBLE,componentsPerAttribute:3,values:l})},primitiveType:s.LINES,boundingSphere:m})},O.createAttributeLocations=function(e){if(!S(e))throw new T("geometry is required.");let t=["position","positionHigh","positionLow","position3DHigh","position3DLow","position2DHigh","position2DLow","pickColor","normal","st","tangent","bitangent","extrudeDirection","compressedAttributes"],r=e.attributes,i={},n=0,o,s=t.length;for(o=0;o<s;++o){let e=t[o];S(r[e])&&(i[e]=n++)}for(let e in r)r.hasOwnProperty(e)&&!S(i[e])&&(i[e]=n++);return i},O.reorderForPreVertexCache=function(e){if(!S(e))throw new T("geometry is required.");let t=a.computeNumberOfVertices(e),r=e.indices;if(S(r)){let i=new Int32Array(t);for(let e=0;e<t;e++)i[e]=-1;let o=r.length,s=n.createTypedArray(t,o),a=0,u=0,l=0,p;for(;a<o;)-1!==(p=i[r[a]])?s[u]=p:(i[p=r[a]]=l,s[u]=l,++l),++a,++u;e.indices=s;let c=e.attributes;for(let e in c)if(c.hasOwnProperty(e)&&S(c[e])&&S(c[e].values)){let r=c[e],n=r.values,o=0,s=r.componentsPerAttribute,a=y.createTypedArray(r.componentDatatype,l*s);for(;o<t;){let e=i[o];if(-1!==e)for(let t=0;t<s;t++)a[s*e+t]=n[s*o+t];++o}r.values=a}}return e},O.reorderForPostVertexCache=function(e,t){if(!S(e))throw new T("geometry is required.");let r=e.indices;if(e.primitiveType===s.TRIANGLES&&S(r)){let i=r.length,n=0;for(let e=0;e<i;e++)r[e]>n&&(n=r[e]);e.indices=I.tipsify({indices:r,maximumIndex:n,cacheSize:t})}return e},O.fitToUnsignedShortIndices=function(e){if(!S(e))throw new T("geometry is required.");if(S(e.indices)&&e.primitiveType!==s.TRIANGLES&&e.primitiveType!==s.LINES&&e.primitiveType!==s.POINTS)throw new T("geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.");let t=[],r=a.computeNumberOfVertices(e);if(S(e.indices)&&r>=w.SIXTY_FOUR_KILOBYTES){let r=[],i=[],n=0,o=z(e.attributes),u=e.indices,l=u.length,p;e.primitiveType===s.TRIANGLES?p=3:e.primitiveType===s.LINES?p=2:e.primitiveType===s.POINTS&&(p=1);for(let s=0;s<l;s+=p){for(let t=0;t<p;++t){let a=u[s+t],l=r[a];S(l)||(l=n++,r[a]=l,function(e,t,r){for(let i in t)if(t.hasOwnProperty(i)&&S(t[i])&&S(t[i].values)){let n=t[i];for(let t=0;t<n.componentsPerAttribute;++t)e[i].values.push(n.values[r*n.componentsPerAttribute+t])}}(o,e.attributes,a)),i.push(l)}n+p>=w.SIXTY_FOUR_KILOBYTES&&(t.push(new a({attributes:o,indices:i,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV})),r=[],i=[],n=0,o=z(e.attributes))}0!==i.length&&t.push(new a({attributes:o,indices:i,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV}))}else t.push(e);return t};var D=new h,q=new d;O.projectTo2D=function(e,t,r,i,n){if(!S(e))throw new T("geometry is required.");if(!S(t))throw new T("attributeName is required.");if(!S(r))throw new T("attributeName3D is required.");if(!S(i))throw new T("attributeName2D is required.");if(!S(e.attributes[t]))throw new T(`geometry must have attribute matching the attributeName argument: ${t}.`);if(e.attributes[t].componentDatatype!==y.DOUBLE)throw new T("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");let o=e.attributes[t],s=(n=S(n)?n:new l).ellipsoid,a=o.values,p=new Float64Array(a.length),c=0;for(let e=0;e<a.length;e+=3){let t=h.fromArray(a,e,D),r=s.cartesianToCartographic(t,q);if(!S(r))throw new T(`Could not project point (${t.x}, ${t.y}, ${t.z}) to 2D.`);let i=n.project(r,D);p[c++]=i.x,p[c++]=i.y,p[c++]=i.z}return e.attributes[r]=o,e.attributes[i]=new u({componentDatatype:y.DOUBLE,componentsPerAttribute:3,values:p}),delete e.attributes[t],e};var R={high:0,low:0};O.encodeAttribute=function(e,r,i,n){if(!S(e))throw new T("geometry is required.");if(!S(r))throw new T("attributeName is required.");if(!S(i))throw new T("attributeHighName is required.");if(!S(n))throw new T("attributeLowName is required.");if(!S(e.attributes[r]))throw new T(`geometry must have attribute matching the attributeName argument: ${r}.`);if(e.attributes[r].componentDatatype!==y.DOUBLE)throw new T("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");let o=e.attributes[r],s=o.values,a=s.length,l=new Float32Array(a),p=new Float32Array(a);for(let e=0;e<a;++e)t.encode(s[e],R),l[e]=R.high,p[e]=R.low;let c=o.componentsPerAttribute;return e.attributes[i]=new u({componentDatatype:y.FLOAT,componentsPerAttribute:c,values:l}),e.attributes[n]=new u({componentDatatype:y.FLOAT,componentsPerAttribute:c,values:p}),delete e.attributes[r],e};var k=new h;function G(e,t){if(S(t)){let r=t.values,i=r.length;for(let t=0;t<i;t+=3)h.unpack(r,t,k),f.multiplyByPoint(e,k,k),h.pack(k,r,t)}}function C(e,t){if(S(t)){let r=t.values,i=r.length;for(let t=0;t<i;t+=3)h.unpack(r,t,k),b.multiplyByVector(e,k,k),k=h.normalize(k,k),h.pack(k,r,t)}}var B=new f,F=new b;O.transformToWorldCoordinates=function(e){if(!S(e))throw new T("instance is required.");let t=e.modelMatrix;if(f.equals(t,f.IDENTITY))return e;let r=e.geometry.attributes;G(t,r.position),G(t,r.prevPosition),G(t,r.nextPosition),(S(r.normal)||S(r.tangent)||S(r.bitangent))&&(f.inverse(t,B),f.transpose(B,B),f.getMatrix3(B,F),C(F,r.normal),C(F,r.tangent),C(F,r.bitangent));let i=e.geometry.boundingSphere;return S(i)&&(e.geometry.boundingSphere=c.transform(i,t,i)),e.modelMatrix=f.clone(f.IDENTITY),e};var V=new h;function U(e,t){let r,i=e.length,o,l,p,m,d=e[0].modelMatrix,v=S(e[0][t].indices),b=e[0][t].primitiveType;for(l=1;l<i;++l){if(!f.equals(e[l].modelMatrix,d))throw new T("All instances must have the same modelMatrix.");if(S(e[l][t].indices)!==v)throw new T("All instance geometries must have an indices or not have one.");if(e[l][t].primitiveType!==b)throw new T("All instance geometries must have the same primitiveType.")}let w=function(e,t){let r=e.length,i={},n=e[0][t].attributes,o;for(o in n)if(n.hasOwnProperty(o)&&S(n[o])&&S(n[o].values)){let s=n[o],a=s.values.length,l=!0;for(let i=1;i<r;++i){let r=e[i][t].attributes[o];if(!S(r)||s.componentDatatype!==r.componentDatatype||s.componentsPerAttribute!==r.componentsPerAttribute||s.normalize!==r.normalize){l=!1;break}a+=r.values.length}l&&(i[o]=new u({componentDatatype:s.componentDatatype,componentsPerAttribute:s.componentsPerAttribute,normalize:s.normalize,values:y.createTypedArray(s.componentDatatype,a)}))}return i}(e,t),g,A,N;for(o in w)if(w.hasOwnProperty(o))for(g=w[o].values,m=0,l=0;l<i;++l)for(N=(A=e[l][t].attributes[o].values).length,p=0;p<N;++p)g[m++]=A[p];if(v){let o=0;for(l=0;l<i;++l)o+=e[l][t].indices.length;let u=a.computeNumberOfVertices(new a({attributes:w,primitiveType:s.POINTS})),p=n.createTypedArray(u,o),c=0,f=0;for(l=0;l<i;++l){let r=e[l][t].indices,i=r.length;for(m=0;m<i;++m)p[c++]=f+r[m];f+=a.computeNumberOfVertices(e[l][t])}r=p}let x=new h,P=0,E;for(l=0;l<i;++l){if(!S(E=e[l][t].boundingSphere)){x=void 0;break}h.add(E.center,x,x)}if(S(x))for(h.divideByScalar(x,i,x),l=0;l<i;++l){E=e[l][t].boundingSphere;let r=h.magnitude(h.subtract(E.center,x,V))+E.radius;r>P&&(P=r)}return new a({attributes:w,indices:r,primitiveType:b,boundingSphere:S(x)?new c(x,P):void 0})}O.combineInstances=function(e){if(!S(e)||e.length<1)throw new T("instances is required and must have length greater than zero.");let t=[],r=[],i=e.length;for(let n=0;n<i;++n){let i=e[n];S(i.geometry)?t.push(i):S(i.westHemisphereGeometry)&&S(i.eastHemisphereGeometry)&&r.push(i)}let n=[];return t.length>0&&n.push(U(t,"geometry")),r.length>0&&(n.push(U(r,"westHemisphereGeometry")),n.push(U(r,"eastHemisphereGeometry"))),n};var _=new h,M=new h,Y=new h,j=new h;O.computeNormal=function(e){let t;if(!S(e))throw new T("geometry is required.");if(!S(e.attributes.position)||!S(e.attributes.position.values))throw new T("geometry.attributes.position.values is required.");if(!S(e.indices))throw new T("geometry.indices is required.");if(e.indices.length<2||e.indices.length%3!=0)throw new T("geometry.indices length must be greater than 0 and be a multiple of 3.");if(e.primitiveType!==s.TRIANGLES)throw new T("geometry.primitiveType must be PrimitiveType.TRIANGLES.");let r=e.indices,i=e.attributes,n=i.position.values,o=i.position.values.length/3,a=r.length,l=Array(o),p=Array(a/3),c=Array(a),m;for(m=0;m<o;m++)l[m]={indexOffset:0,count:0,currentCount:0};let f=0;for(m=0;m<a;m+=3){let e=r[m],t=r[m+1],i=r[m+2],o=3*e,s=3*t,a=3*i;M.x=n[o],M.y=n[o+1],M.z=n[o+2],Y.x=n[s],Y.y=n[s+1],Y.z=n[s+2],j.x=n[a],j.y=n[a+1],j.z=n[a+2],l[e].count++,l[t].count++,l[i].count++,h.subtract(Y,M,Y),h.subtract(j,M,j),p[f]=h.cross(Y,j,new h),f++}let d=0;for(m=0;m<o;m++)l[m].indexOffset+=d,d+=l[m].count;for(m=0,f=0;m<a;m+=3){let e=(t=l[r[m]]).indexOffset+t.currentCount;c[e]=f,t.currentCount++,c[e=(t=l[r[m+1]]).indexOffset+t.currentCount]=f,t.currentCount++,c[e=(t=l[r[m+2]]).indexOffset+t.currentCount]=f,t.currentCount++,f++}let v=new Float32Array(3*o);for(m=0;m<o;m++){let e=3*m;if(t=l[m],h.clone(h.ZERO,_),t.count>0){for(f=0;f<t.count;f++)h.add(_,p[c[t.indexOffset+f]],_);h.equalsEpsilon(h.ZERO,_,w.EPSILON10)&&h.clone(p[c[t.indexOffset]],_)}h.equalsEpsilon(h.ZERO,_,w.EPSILON10)&&(_.z=1),h.normalize(_,_),v[e]=_.x,v[e+1]=_.y,v[e+2]=_.z}return e.attributes.normal=new u({componentDatatype:y.FLOAT,componentsPerAttribute:3,values:v}),e};var Z=new h,H=new h,W=new h;O.computeTangentAndBitangent=function(e){let t,r,i;if(!S(e))throw new T("geometry is required.");let n=e.attributes,o=e.indices;if(!S(n.position)||!S(n.position.values))throw new T("geometry.attributes.position.values is required.");if(!S(n.normal)||!S(n.normal.values))throw new T("geometry.attributes.normal.values is required.");if(!S(n.st)||!S(n.st.values))throw new T("geometry.attributes.st.values is required.");if(!S(o))throw new T("geometry.indices is required.");if(o.length<2||o.length%3!=0)throw new T("geometry.indices length must be greater than 0 and be a multiple of 3.");if(e.primitiveType!==s.TRIANGLES)throw new T("geometry.primitiveType must be PrimitiveType.TRIANGLES.");let a=e.attributes.position.values,l=e.attributes.normal.values,p=e.attributes.st.values,c=e.attributes.position.values.length/3,m=o.length,f=Array(3*c),d;for(d=0;d<f.length;d++)f[d]=0;for(d=0;d<m;d+=3){let e=o[d],n=o[d+1],s=o[d+2];t=3*e,r=3*n,i=3*s;let u=2*e,l=2*n,c=2*s,m=a[t],y=a[t+1],h=a[t+2],v=p[u],b=p[u+1],w=p[l+1]-b,g=p[c+1]-b,T=1/((p[l]-v)*g-(p[c]-v)*w),A=(g*(a[r]-m)-w*(a[i]-m))*T,S=(g*(a[r+1]-y)-w*(a[i+1]-y))*T,N=(g*(a[r+2]-h)-w*(a[i+2]-h))*T;f[t]+=A,f[t+1]+=S,f[t+2]+=N,f[r]+=A,f[r+1]+=S,f[r+2]+=N,f[i]+=A,f[i+1]+=S,f[i+2]+=N}let v=new Float32Array(3*c),b=new Float32Array(3*c);for(d=0;d<c;d++){r=(t=3*d)+1,i=t+2;let e=h.fromArray(l,t,Z),n=h.fromArray(f,t,W),o=h.dot(e,n);h.multiplyByScalar(e,o,H),h.normalize(h.subtract(n,H,n),n),v[t]=n.x,v[r]=n.y,v[i]=n.z,h.normalize(h.cross(e,n,n),n),b[t]=n.x,b[r]=n.y,b[i]=n.z}return e.attributes.tangent=new u({componentDatatype:y.FLOAT,componentsPerAttribute:3,values:v}),e.attributes.bitangent=new u({componentDatatype:y.FLOAT,componentsPerAttribute:3,values:b}),e};var J=new v,X=new h,$=new h,K=new h,Q=new v;function ee(e,t){Math.abs(e.y)<w.EPSILON6&&(t?e.y=-w.EPSILON6:e.y=w.EPSILON6)}O.compressVertices=function(t){if(!S(t))throw new T("geometry is required.");let r=t.attributes.extrudeDirection,i,n;if(S(r)){let o=r.values,s=new Float32Array(2*(n=o.length/3)),a=0;for(i=0;i<n;++i){if(h.fromArray(o,3*i,X),h.equals(X,h.ZERO)){a+=2;continue}Q=e.octEncodeInRange(X,65535,Q),s[a++]=Q.x,s[a++]=Q.y}return t.attributes.compressedAttributes=new u({componentDatatype:y.FLOAT,componentsPerAttribute:2,values:s}),delete t.attributes.extrudeDirection,t}let o=t.attributes.normal,s=t.attributes.st,a=S(o),l=S(s);if(!a&&!l)return t;let p=t.attributes.tangent,c=t.attributes.bitangent,m=S(p),f=S(c),d,b,w,g;a&&(d=o.values),l&&(b=s.values),m&&(w=p.values),f&&(g=c.values);let A=n=(a?d.length:b.length)/(a?3:2),N=l&&a?2:1;N+=m||f?1:0;let x=new Float32Array(A*=N),P=0;for(i=0;i<n;++i){l&&(v.fromArray(b,2*i,J),x[P++]=e.compressTextureCoordinates(J));let t=3*i;a&&S(w)&&S(g)?(h.fromArray(d,t,X),h.fromArray(w,t,$),h.fromArray(g,t,K),e.octPack(X,$,K,J),x[P++]=J.x,x[P++]=J.y):(a&&(h.fromArray(d,t,X),x[P++]=e.octEncodeFloat(X)),m&&(h.fromArray(w,t,X),x[P++]=e.octEncodeFloat(X)),f&&(h.fromArray(g,t,X),x[P++]=e.octEncodeFloat(X)))}return t.attributes.compressedAttributes=new u({componentDatatype:y.FLOAT,componentsPerAttribute:N,values:x}),a&&delete t.attributes.normal,l&&delete t.attributes.st,f&&delete t.attributes.bitangent,m&&delete t.attributes.tangent,t};var et=new h;function er(e,t,r,i){h.add(e,h.multiplyByScalar(h.subtract(t,e,et),e.y/(e.y-t.y),et),r),h.clone(r,i),ee(r,!0),ee(i,!1)}var ei=new h,en=new h,eo=new h,es=new h,ea={positions:Array(7),indices:Array(9)};function eu(e,t){let r=e.attributes;if(0===r.position.values.length)return;for(let e in r)if(r.hasOwnProperty(e)&&S(r[e])&&S(r[e].values)){let t=r[e];t.values=y.createTypedArray(t.componentDatatype,t.values)}let i=a.computeNumberOfVertices(e);return e.indices=n.createTypedArray(i,e.indices),t&&(e.boundingSphere=c.fromVertices(r.position.values)),e}function el(e){let t=e.attributes,r={};for(let e in t)if(t.hasOwnProperty(e)&&S(t[e])&&S(t[e].values)){let i=t[e];r[e]=new u({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return new a({attributes:r,indices:[],primitiveType:e.primitiveType})}function ep(e,t,r){let i=S(e.geometry.boundingSphere);t=eu(t,i),S(r=eu(r,i))&&!S(t)?e.geometry=r:!S(r)&&S(t)?e.geometry=t:(e.westHemisphereGeometry=t,e.eastHemisphereGeometry=r,e.geometry=void 0)}function ec(e,t){let r=new e,i=new e,n=new e;return function(o,s,a,u,l,p,c,m){let f=e.fromArray(l,o*t,r),y=e.fromArray(l,s*t,i),h=e.fromArray(l,a*t,n);e.multiplyByScalar(f,u.x,f),e.multiplyByScalar(y,u.y,y),e.multiplyByScalar(h,u.z,h);let d=e.add(f,y,f);e.add(d,h,d),m&&e.normalize(d,d),e.pack(d,p,c*t)}}var em=ec(m,4),ef=ec(h,3),ey=ec(v,2),eh=function(e,t,r,i,n,o,s){let a=n[e]*i.x,u=n[t]*i.y,l=n[r]*i.z;o[s]=+(a+u+l>w.EPSILON6)},ed=new h,ev=new h,eb=new h,ew=new h;function eg(e,t,r,i,n,o,s,a,u,l,p,c,m,f,y,d){if(!S(o)&&!S(s)&&!S(a)&&!S(u)&&!S(l)&&0===f)return;let v=E(i,h.fromArray(n,3*e,ed),h.fromArray(n,3*t,ev),h.fromArray(n,3*r,eb),ew);if(S(v)){if(S(o)&&ef(e,t,r,v,o,c.normal.values,d,!0),S(l)){let i,n=h.fromArray(l,3*e,ed),o=h.fromArray(l,3*t,ev),s=h.fromArray(l,3*r,eb);h.multiplyByScalar(n,v.x,n),h.multiplyByScalar(o,v.y,o),h.multiplyByScalar(s,v.z,s),h.equals(n,h.ZERO)&&h.equals(o,h.ZERO)&&h.equals(s,h.ZERO)?((i=ed).x=0,i.y=0,i.z=0):(i=h.add(n,o,n),h.add(i,s,i),h.normalize(i,i)),h.pack(i,c.extrudeDirection.values,3*d)}if(S(p)&&eh(e,t,r,v,p,c.applyOffset.values,d),S(s)&&ef(e,t,r,v,s,c.tangent.values,d,!0),S(a)&&ef(e,t,r,v,a,c.bitangent.values,d,!0),S(u)&&ey(e,t,r,v,u,c.st.values,d),f>0)for(let i=0;i<f;i++){let n=m[i];!function(e,t,r,i,n,o,s){let a=o.componentsPerAttribute,u=o.values,l=s.values;switch(a){case 4:em(e,t,r,i,u,l,n,!1);break;case 3:ef(e,t,r,i,u,l,n,!1);break;case 2:ey(e,t,r,i,u,l,n,!1);break;default:l[n]=u[e]*i.x+u[t]*i.y+u[r]*i.z}}(e,t,r,v,d,y[n],c[n])}}}function eT(e,t,r,i,n,o){let s=e.position.values.length/3;if(-1!==n){let a=i[n],u=r[a];return -1===u?(r[a]=s,e.position.values.push(o.x,o.y,o.z),t.push(s),s):(t.push(u),u)}return e.position.values.push(o.x,o.y,o.z),t.push(s),s}var eA={position:!0,normal:!0,bitangent:!0,tangent:!0,st:!0,extrudeDirection:!0,applyOffset:!0};function eS(e){let t=e.geometry,r=t.attributes,i=r.position.values,n=S(r.normal)?r.normal.values:void 0,o=S(r.bitangent)?r.bitangent.values:void 0,s=S(r.tangent)?r.tangent.values:void 0,a=S(r.st)?r.st.values:void 0,u=S(r.extrudeDirection)?r.extrudeDirection.values:void 0,l=S(r.applyOffset)?r.applyOffset.values:void 0,p=t.indices,c=[];for(let e in r)r.hasOwnProperty(e)&&!eA[e]&&S(r[e])&&c.push(e);let m=c.length,f=el(t),y=el(t),d,v,b,g,T,A=[];A.length=i.length/3;let N=[];for(N.length=i.length/3,T=0;T<A.length;++T)A[T]=-1,N[T]=-1;let x=p.length;for(T=0;T<x;T+=3){let e=p[T],t=p[T+1],x=p[T+2],P=h.fromArray(i,3*e),E=h.fromArray(i,3*t),I=h.fromArray(i,3*x),O=function(e,t,r){if(e.x>=0||t.x>=0||r.x>=0)return;!function(e,t,r){if(0!==e.y&&0!==t.y&&0!==r.y){ee(e,e.y<0),ee(t,t.y<0),ee(r,r.y<0);return}let i=Math.abs(e.y),n=Math.abs(t.y),o=Math.abs(r.y),s,a=(i>n?i>o?w.sign(e.y):w.sign(r.y):n>o?w.sign(t.y):w.sign(r.y))<0;ee(e,a),ee(t,a),ee(r,a)}(e,t,r);let i=e.y<0,n=t.y<0,o=r.y<0,s;s=0+(+!!i+ +!!n+ +!!o);let a=ea.indices;1===s?(a[1]=3,a[2]=4,a[5]=6,a[7]=6,a[8]=5,i?(er(e,t,ei,eo),er(e,r,en,es),a[0]=0,a[3]=1,a[4]=2,a[6]=1):n?(er(t,r,ei,eo),er(t,e,en,es),a[0]=1,a[3]=2,a[4]=0,a[6]=2):o&&(er(r,e,ei,eo),er(r,t,en,es),a[0]=2,a[3]=0,a[4]=1,a[6]=0)):2===s&&(a[2]=4,a[4]=4,a[5]=3,a[7]=5,a[8]=6,i?n?o||(er(r,e,ei,eo),er(r,t,en,es),a[0]=0,a[1]=1,a[3]=0,a[6]=2):(er(t,r,ei,eo),er(t,e,en,es),a[0]=2,a[1]=0,a[3]=2,a[6]=1):(er(e,t,ei,eo),er(e,r,en,es),a[0]=1,a[1]=2,a[3]=1,a[6]=0));let u=ea.positions;return u[0]=e,u[1]=t,u[2]=r,u.length=3,(1===s||2===s)&&(u[3]=ei,u[4]=en,u[5]=eo,u[6]=es,u.length=7),ea}(P,E,I);if(S(O)&&O.positions.length>3){let h=O.positions,w=O.indices,S=w.length;for(let P=0;P<S;++P){let S=w[P],E=h[S];E.y<0?(d=y.attributes,v=y.indices,b=A):(d=f.attributes,v=f.indices,b=N),g=eT(d,v,b,p,S<3?T+S:-1,E),eg(e,t,x,E,i,n,s,o,a,u,l,d,c,m,r,g)}}else S(O)&&(P=O.positions[0],E=O.positions[1],I=O.positions[2]),P.y<0?(d=y.attributes,v=y.indices,b=A):(d=f.attributes,v=f.indices,b=N),g=eT(d,v,b,p,T,P),eg(e,t,x,P,i,n,s,o,a,u,l,d,c,m,r,g),g=eT(d,v,b,p,T+1,E),eg(e,t,x,E,i,n,s,o,a,u,l,d,c,m,r,g),g=eT(d,v,b,p,T+2,I),eg(e,t,x,I,i,n,s,o,a,u,l,d,c,m,r,g)}ep(e,y,f)}var eN=i.fromPointNormal(h.ZERO,h.UNIT_Y),ex=new h,eP=new h;function eE(e,t,r,i,n,o,s){if(!S(s))return;let a=h.fromArray(i,3*e,ed);h.equalsEpsilon(a,r,w.EPSILON10)?o.applyOffset.values[n]=s[e]:o.applyOffset.values[n]=s[t]}function eI(e){let t=e.geometry,i=t.attributes,n=i.position.values,o=S(i.applyOffset)?i.applyOffset.values:void 0,s=t.indices,a=el(t),u=el(t),l,p=s.length,c=[];c.length=n.length/3;let m=[];for(m.length=n.length/3,l=0;l<c.length;++l)c[l]=-1,m[l]=-1;for(l=0;l<p;l+=2){let e=s[l],t=s[l+1],i=h.fromArray(n,3*e,ed),p=h.fromArray(n,3*t,ev),f;Math.abs(i.y)<w.EPSILON6&&(i.y<0?i.y=-w.EPSILON6:i.y=w.EPSILON6),Math.abs(p.y)<w.EPSILON6&&(p.y<0?p.y=-w.EPSILON6:p.y=w.EPSILON6);let y=a.attributes,d=a.indices,v=m,b=u.attributes,g=u.indices,T=c,A=r.lineSegmentPlane(i,p,eN,eb);if(S(A)){let r=h.multiplyByScalar(h.UNIT_Y,5*w.EPSILON9,ex);i.y<0&&(h.negate(r,r),y=u.attributes,d=u.indices,v=c,b=a.attributes,g=a.indices,T=m);let S=h.add(A,r,eP);f=eT(y,d,v,s,l,i),eE(e,t,i,n,f,y,o),f=eT(y,d,v,s,-1,S),eE(e,t,S,n,f,y,o),h.negate(r,r),h.add(A,r,S),f=eT(b,g,T,s,-1,S),eE(e,t,S,n,f,b,o),f=eT(b,g,T,s,l+1,p),eE(e,t,p,n,f,b,o)}else{let r,y,h;i.y<0?(r=u.attributes,y=u.indices,h=c):(r=a.attributes,y=a.indices,h=m),f=eT(r,y,h,s,l,i),eE(e,t,i,n,f,r,o),f=eT(r,y,h,s,l+1,p),eE(e,t,p,n,f,r,o)}}ep(e,u,a)}var eO=new v,eL=new v,ez=new h,eD=new h,eq=new h,eR=new h,ek=new h,eG=new h,eC=new m;function eB(e){let t=e.attributes,r=t.position.values,i=t.prevPosition.values,n=t.nextPosition.values,o=r.length;for(let e=0;e<o;e+=3){let t=h.unpack(r,e,ez);if(t.x>0)continue;let s=h.unpack(i,e,eD);(t.y<0&&s.y>0||t.y>0&&s.y<0)&&(e-3>0?(i[e]=r[e-3],i[e+1]=r[e-2],i[e+2]=r[e-1]):h.pack(t,i,e));let a=h.unpack(n,e,eq);(t.y<0&&a.y>0||t.y>0&&a.y<0)&&(e+3<o?(n[e]=r[e+3],n[e+1]=r[e+4],n[e+2]=r[e+5]):h.pack(t,n,e))}}var eF=5*w.EPSILON9,eV=w.EPSILON6;O.splitLongitude=function(e){if(!S(e))throw new T("instance is required.");let t=e.geometry,u=t.boundingSphere;if(S(u)&&(u.center.x-u.radius>0||c.intersectPlane(u,i.ORIGIN_ZX_PLANE)!==p.INTERSECTING))return e;if(t.geometryType!==o.NONE)switch(t.geometryType){case o.POLYLINES:!function(e){let t=e.geometry,i=t.attributes,n=i.position.values,o=i.prevPosition.values,s=i.nextPosition.values,a=i.expandAndWidth.values,u=S(i.st)?i.st.values:void 0,l=S(i.color)?i.color.values:void 0,p=el(t),c=el(t),f,y,d,b=!1,g=n.length/3;for(f=0;f<g;f+=4){let e=f,t=f+2,i=h.fromArray(n,3*e,ez),g=h.fromArray(n,3*t,eD);if(Math.abs(i.y)<eV)for(i.y=eV*(g.y<0?-1:1),n[3*f+1]=i.y,n[(f+1)*3+1]=i.y,y=3*e;y<3*e+12;y+=3)o[y]=n[3*f],o[y+1]=n[3*f+1],o[y+2]=n[3*f+2];if(Math.abs(g.y)<eV)for(g.y=eV*(i.y<0?-1:1),n[(f+2)*3+1]=g.y,n[(f+3)*3+1]=g.y,y=3*e;y<3*e+12;y+=3)s[y]=n[(f+2)*3],s[y+1]=n[(f+2)*3+1],s[y+2]=n[(f+2)*3+2];let T=p.attributes,A=p.indices,N=c.attributes,x=c.indices,P=r.lineSegmentPlane(i,g,eN,eR);if(S(P)){b=!0;let r=h.multiplyByScalar(h.UNIT_Y,eF,ek);i.y<0&&(h.negate(r,r),T=c.attributes,A=c.indices,N=p.attributes,x=p.indices);let n=h.add(P,r,eG);T.position.values.push(i.x,i.y,i.z,i.x,i.y,i.z),T.position.values.push(n.x,n.y,n.z),T.position.values.push(n.x,n.y,n.z),T.prevPosition.values.push(o[3*e],o[3*e+1],o[3*e+2]),T.prevPosition.values.push(o[3*e+3],o[3*e+4],o[3*e+5]),T.prevPosition.values.push(i.x,i.y,i.z,i.x,i.y,i.z),T.nextPosition.values.push(n.x,n.y,n.z),T.nextPosition.values.push(n.x,n.y,n.z),T.nextPosition.values.push(n.x,n.y,n.z),T.nextPosition.values.push(n.x,n.y,n.z),h.negate(r,r),h.add(P,r,n),N.position.values.push(n.x,n.y,n.z),N.position.values.push(n.x,n.y,n.z),N.position.values.push(g.x,g.y,g.z,g.x,g.y,g.z),N.prevPosition.values.push(n.x,n.y,n.z),N.prevPosition.values.push(n.x,n.y,n.z),N.prevPosition.values.push(n.x,n.y,n.z),N.prevPosition.values.push(n.x,n.y,n.z),N.nextPosition.values.push(g.x,g.y,g.z,g.x,g.y,g.z),N.nextPosition.values.push(s[3*t],s[3*t+1],s[3*t+2]),N.nextPosition.values.push(s[3*t+3],s[3*t+4],s[3*t+5]);let E=Math.abs(v.fromArray(a,2*e,eO).y);T.expandAndWidth.values.push(-1,E,1,E),T.expandAndWidth.values.push(-1,-E,1,-E),N.expandAndWidth.values.push(-1,E,1,E),N.expandAndWidth.values.push(-1,-E,1,-E);let I=h.magnitudeSquared(h.subtract(P,i,eq));if(I/=h.magnitudeSquared(h.subtract(g,i,eq)),S(l)){let r=m.fromArray(l,4*e,eC),i=m.fromArray(l,4*t,eC),n=w.lerp(r.x,i.x,I),o=w.lerp(r.y,i.y,I),s=w.lerp(r.z,i.z,I),a=w.lerp(r.w,i.w,I);for(y=4*e;y<4*e+8;++y)T.color.values.push(l[y]);for(T.color.values.push(n,o,s,a),T.color.values.push(n,o,s,a),N.color.values.push(n,o,s,a),N.color.values.push(n,o,s,a),y=4*t;y<4*t+8;++y)N.color.values.push(l[y])}if(S(u)){let r=v.fromArray(u,2*e,eO),i=v.fromArray(u,(f+3)*2,eL),n=w.lerp(r.x,i.x,I);for(y=2*e;y<2*e+4;++y)T.st.values.push(u[y]);for(T.st.values.push(n,r.y),T.st.values.push(n,i.y),N.st.values.push(n,r.y),N.st.values.push(n,i.y),y=2*t;y<2*t+4;++y)N.st.values.push(u[y])}d=T.position.values.length/3-4,A.push(d,d+2,d+1),A.push(d+1,d+2,d+3),d=N.position.values.length/3-4,x.push(d,d+2,d+1),x.push(d+1,d+2,d+3)}else{let e,t;for(i.y<0?(e=c.attributes,t=c.indices):(e=p.attributes,t=p.indices),e.position.values.push(i.x,i.y,i.z),e.position.values.push(i.x,i.y,i.z),e.position.values.push(g.x,g.y,g.z),e.position.values.push(g.x,g.y,g.z),y=3*f;y<3*f+12;++y)e.prevPosition.values.push(o[y]),e.nextPosition.values.push(s[y]);for(y=2*f;y<2*f+8;++y)e.expandAndWidth.values.push(a[y]),S(u)&&e.st.values.push(u[y]);if(S(l))for(y=4*f;y<4*f+16;++y)e.color.values.push(l[y]);d=e.position.values.length/3-4,t.push(d,d+2,d+1),t.push(d+1,d+2,d+3)}}b&&(eB(c),eB(p)),ep(e,c,p)}(e);break;case o.TRIANGLES:eS(e);break;case o.LINES:eI(e)}else(function(e){switch(e.primitiveType){case s.TRIANGLE_FAN:return function(e){let t=a.computeNumberOfVertices(e);if(t<3)throw new T("The number of vertices must be at least three.");let r=n.createTypedArray(t,(t-2)*3);r[0]=1,r[1]=0,r[2]=2;let i=3;for(let e=3;e<t;++e)r[i++]=e-1,r[i++]=0,r[i++]=e;e.indices=r,e.primitiveType=s.TRIANGLES}(e);case s.TRIANGLE_STRIP:return function(e){let t=a.computeNumberOfVertices(e);if(t<3)throw new T("The number of vertices must be at least 3.");let r=n.createTypedArray(t,(t-2)*3);r[0]=0,r[1]=1,r[2]=2,t>3&&(r[3]=0,r[4]=2,r[5]=3);let i=6;for(let e=3;e<t-1;e+=2)r[i++]=e,r[i++]=e-1,r[i++]=e+1,e+2<t&&(r[i++]=e,r[i++]=e+1,r[i++]=e+2);e.indices=r,e.primitiveType=s.TRIANGLES}(e);case s.TRIANGLES:return function(e){if(S(e.indices))return;let t=a.computeNumberOfVertices(e);if(t<3)throw new T("The number of vertices must be at least three.");if(t%3!=0)throw new T("The number of vertices must be a multiple of three.");let r=n.createTypedArray(t,t);for(let e=0;e<t;++e)r[e]=e;e.indices=r}(e);case s.LINE_STRIP:return function(e){let t=a.computeNumberOfVertices(e);if(t<2)throw new T("The number of vertices must be at least two.");let r=n.createTypedArray(t,(t-1)*2);r[0]=0,r[1]=1;let i=2;for(let e=2;e<t;++e)r[i++]=e-1,r[i++]=e;e.indices=r,e.primitiveType=s.LINES}(e);case s.LINE_LOOP:return function(e){let t=a.computeNumberOfVertices(e);if(t<2)throw new T("The number of vertices must be at least two.");let r=n.createTypedArray(t,2*t);r[0]=0,r[1]=1;let i=2;for(let e=2;e<t;++e)r[i++]=e-1,r[i++]=e;r[i++]=t-1,r[i]=0,e.indices=r,e.primitiveType=s.LINES}(e);case s.LINES:return function(e){if(S(e.indices))return;let t=a.computeNumberOfVertices(e);if(t<2)throw new T("The number of vertices must be at least two.");if(t%2!=0)throw new T("The number of vertices must be a multiple of 2.");let r=n.createTypedArray(t,t);for(let e=0;e<t;++e)r[e]=e;e.indices=r}(e)}})(t),t.primitiveType===s.TRIANGLES?eS(e):t.primitiveType===s.LINES&&eI(e);return e};var eU=O;export{eU as a};