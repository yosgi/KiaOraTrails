import{b as t,f as e,g as n,h as r,i as i}from"./chunk-YWRPWWKI.js";import{a as o,b as s,c as a,e as u}from"./chunk-JMSSU44E.js";import{a as I}from"./chunk-ANLJ4KBN.js";import{a as N}from"./chunk-VLPNAR64.js";import{a as m,b as p}from"./chunk-GE5NEIZC.js";import{e as T}from"./chunk-35CVRQTC.js";var c=Object.freeze({NONE:0,TRIANGLES:1,LINES:2,POLYLINES:3}),E={POINTS:I.POINTS,LINES:I.LINES,LINE_LOOP:I.LINE_LOOP,LINE_STRIP:I.LINE_STRIP,TRIANGLES:I.TRIANGLES,TRIANGLE_STRIP:I.TRIANGLE_STRIP,TRIANGLE_FAN:I.TRIANGLE_FAN};E.isLines=function(t){return t===E.LINES||t===E.LINE_LOOP||t===E.LINE_STRIP},E.isTriangles=function(t){return t===E.TRIANGLES||t===E.TRIANGLE_STRIP||t===E.TRIANGLE_FAN},E.validate=function(t){return t===E.POINTS||t===E.LINES||t===E.LINE_LOOP||t===E.LINE_STRIP||t===E.TRIANGLES||t===E.TRIANGLE_STRIP||t===E.TRIANGLE_FAN};var b=Object.freeze(E);function h(t){t=N(t,N.EMPTY_OBJECT),p.typeOf.object("options.attributes",t.attributes),this.attributes=t.attributes,this.indices=t.indices,this.primitiveType=N(t.primitiveType,b.TRIANGLES),this.boundingSphere=t.boundingSphere,this.geometryType=N(t.geometryType,c.NONE),this.boundingSphereCV=t.boundingSphereCV,this.offsetAttribute=t.offsetAttribute}h.computeNumberOfVertices=function(t){p.typeOf.object("geometry",t);let e=-1;for(let n in t.attributes)if(t.attributes.hasOwnProperty(n)&&T(t.attributes[n])&&T(t.attributes[n].values)){let r=t.attributes[n],i=r.values.length/r.componentsPerAttribute;if(e!==i&&-1!==e)throw new m("All attribute lists must have the same number of attributes.");e=i}return e};var l=new s,A=new o,f=new t,L=[new s,new s,new s],y=[new a,new a,new a],P=[new a,new a,new a],S=new o,w=new e,R=new t,O=new i;h._textureCoordinateRotationPoints=function(I,N,m,p){let T,c=r.center(p,l),E=s.toCartesian(c,m,A),b=n.eastNorthUpToFixedFrame(E,m,f),h=t.inverse(b,f);L[0].longitude=p.west,L[0].latitude=p.south,L[1].longitude=p.west,L[1].latitude=p.north,L[2].longitude=p.east,L[2].latitude=p.south;let _=S;for(T=0;T<3;T++)s.toCartesian(L[T],m,_),_=t.multiplyByPointAsVector(h,_,_),y[T].x=_.x,y[T].y=_.y;let d=e.fromAxisAngle(o.UNIT_Z,-N,w),x=u.fromQuaternion(d,R),G=I.length,g=Number.POSITIVE_INFINITY,v=Number.POSITIVE_INFINITY,V=Number.NEGATIVE_INFINITY,F=Number.NEGATIVE_INFINITY;for(T=0;T<G;T++)_=t.multiplyByPointAsVector(h,I[T],_),g=Math.min(g,(_=u.multiplyByVector(x,_,_)).x),v=Math.min(v,_.y),V=Math.max(V,_.x),F=Math.max(F,_.y);let j=i.fromRotation(N,O);P[0].x=g,P[0].y=v,P[1].x=g,P[1].y=F,P[2].x=V,P[2].y=v;let C=y[0],k=y[2].x-C.x,M=y[1].y-C.y;for(T=0;T<3;T++){let t=P[T];i.multiplyByVector(j,t,t),t.x=(t.x-C.x)/k,t.y=(t.y-C.y)/M}let Y=P[0],B=P[1],z=P[2],D=Array(6);return a.pack(Y,D),a.pack(B,D,2),a.pack(z,D,4),D};var _=h,d=function(t){if(!T((t=N(t,N.EMPTY_OBJECT)).componentDatatype))throw new m("options.componentDatatype is required.");if(!T(t.componentsPerAttribute))throw new m("options.componentsPerAttribute is required.");if(t.componentsPerAttribute<1||t.componentsPerAttribute>4)throw new m("options.componentsPerAttribute must be between 1 and 4.");if(!T(t.values))throw new m("options.values is required.");this.componentDatatype=t.componentDatatype,this.componentsPerAttribute=t.componentsPerAttribute,this.normalize=N(t.normalize,!1),this.values=t.values};export{c as a,b as b,_ as c,d as d};