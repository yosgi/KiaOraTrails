import{a as t,b as e}from"./chunk-AZ3SWEDV.js";import{a as i}from"./chunk-PWAJ3RAI.js";import{a as n}from"./chunk-R3AL5FUL.js";import{a as o}from"./chunk-O3CFQFRB.js";import"./chunk-CXNPIJLB.js";import"./chunk-FNJKWSPR.js";import{a as r}from"./chunk-KSZ5EBRB.js";import"./chunk-V3DSE3OK.js";import"./chunk-FMRIJYNG.js";import{d as a}from"./chunk-BKSIEBAA.js";import{b as s,g as u,h as l}from"./chunk-YWRPWWKI.js";import"./chunk-VTVHUB7E.js";import{a as h,b as c,c as d,d as m}from"./chunk-JMSSU44E.js";import{a as g}from"./chunk-4UYSGV57.js";import"./chunk-ANLJ4KBN.js";import{a as p}from"./chunk-ID6SFQTL.js";import{a as I}from"./chunk-VLPNAR64.js";import"./chunk-GE5NEIZC.js";import{e as E}from"./chunk-35CVRQTC.js";var f=Uint16Array.BYTES_PER_ELEMENT,T=Int32Array.BYTES_PER_ELEMENT,N=Uint32Array.BYTES_PER_ELEMENT,S=Float32Array.BYTES_PER_ELEMENT,x=Float64Array.BYTES_PER_ELEMENT;function A(t,e,i){i=I(i,g);let n=t.length;for(let o=0;o<n;++o)if(i.equalsEpsilon(t[o],e,g.EPSILON12))return o;return -1}var R=new c,B=new h,k=new h,P=new h,b=new s;function F(t,e,i,n,o,r,a,u,l,m,p){let I=u.length;for(let f=0;f<I;++f){let T=u[f],N=T.cartographic,S=T.index,x=t.length,A=N.longitude,k=N.latitude;k=g.clamp(k,-g.PI_OVER_TWO,g.PI_OVER_TWO);let P=N.height-a.skirtHeight;a.hMin=Math.min(a.hMin,P),c.fromRadians(A,k,P,R),m&&(R.longitude+=l),m?f===I-1?R.latitude+=p:0===f&&(R.latitude-=p):R.latitude+=l;let b=a.ellipsoid.cartographicToCartesian(R);t.push(b),e.push(P),i.push(d.clone(i[S])),n.length>0&&n.push(n[S]),o.length>0&&o.push(o[S]),s.multiplyByPoint(a.toENU,b,B);let F=a.minimum,y=a.maximum;h.minimumByComponent(B,F,F),h.maximumByComponent(B,y,y);let v=a.lastBorderPoint;if(E(v)){let t=v.index;r.push(t,x-1,x,x,S,t)}a.lastBorderPoint=T}}var y=i(function(i,I){i.ellipsoid=m.clone(i.ellipsoid),i.rectangle=l.clone(i.rectangle);let y=function(i,l,m,I,y,v,w,M,_,W,j){let C,V,U,Y,L,H;E(I)?(C=I.west,V=I.south,U=I.east,Y=I.north,L=I.width,H=I.height):(C=g.toRadians(y.west),V=g.toRadians(y.south),U=g.toRadians(y.east),Y=g.toRadians(y.north),L=g.toRadians(I.width),H=g.toRadians(I.height));let O=[V,Y],D=[C,U],G=u.eastNorthUpToFixedFrame(l,m),J=s.inverseTransformation(G,b),K,z;_&&(K=n.geodeticLatitudeToMercatorAngle(V),z=1/(n.geodeticLatitudeToMercatorAngle(Y)-K));let Q=1!==v,Z=new DataView(i),q=Number.POSITIVE_INFINITY,X=Number.NEGATIVE_INFINITY;k.x=Number.POSITIVE_INFINITY,k.y=Number.POSITIVE_INFINITY,k.z=Number.POSITIVE_INFINITY,P.x=Number.NEGATIVE_INFINITY,P.y=Number.NEGATIVE_INFINITY,P.z=Number.NEGATIVE_INFINITY;let $=0,tt=0,te=0,ti,tn;for(tn=0;tn<4;++tn){let t=$;ti=Z.getUint32(t,!0),t+=N;let e=g.toRadians(180*Z.getFloat64(t,!0));t+=x,-1===A(D,e)&&D.push(e);let i=g.toRadians(180*Z.getFloat64(t,!0));t+=x,-1===A(O,i)&&O.push(i),t+=2*x;let n=Z.getInt32(t,!0);t+=T,tt+=n,te+=3*(n=Z.getInt32(t,!0)),$+=ti+N}let to=[],tr=[],ta=Array(tt),ts=Array(tt),tu=Array(tt),tl=_?Array(tt):[],th=Q?Array(tt):[],tc=Array(te),td=[],tm=[],tg=[],tp=[],tI=0,tE=0;for($=0,tn=0;tn<4;++tn){ti=Z.getUint32($,!0);let t=$+=N,e=g.toRadians(180*Z.getFloat64($,!0));$+=x;let i=g.toRadians(180*Z.getFloat64($,!0));$+=x;let o=g.toRadians(180*Z.getFloat64($,!0)),r=.5*o;$+=x;let a=g.toRadians(180*Z.getFloat64($,!0)),u=.5*a;$+=x;let l=Z.getInt32($,!0);$+=T;let I=Z.getInt32($,!0);$+=T,$+=T;let E=Array(l);for(let t=0;t<l;++t){let l=e+Z.getUint8($++)*o;R.longitude=l;let p=i+Z.getUint8($++)*a;R.latitude=p;let I=Z.getFloat32($,!0);if($+=S,0!==I&&I<j&&(I*=-Math.pow(2,W)),R.height=I*=6371010,-1!==A(D,l)||-1!==A(O,p)){let e=A(to,R,c);if(-1===e)to.push(c.clone(R)),tr.push(tI);else{E[t]=tr[e];continue}}E[t]=tI,Math.abs(l-C)<r?td.push({index:tI,cartographic:c.clone(R)}):Math.abs(l-U)<r?tg.push({index:tI,cartographic:c.clone(R)}):Math.abs(p-V)<u?tm.push({index:tI,cartographic:c.clone(R)}):Math.abs(p-Y)<u&&tp.push({index:tI,cartographic:c.clone(R)}),q=Math.min(I,q),X=Math.max(I,X),tu[tI]=I;let f=m.cartographicToCartesian(R);if(ta[tI]=f,_&&(tl[tI]=(n.geodeticLatitudeToMercatorAngle(p)-K)*z),Q){let t=m.geodeticSurfaceNormal(f);th[tI]=t}s.multiplyByPoint(J,f,B),h.minimumByComponent(B,k,k),h.maximumByComponent(B,P,P);let T=(l-C)/(U-C);T=g.clamp(T,0,1);let N=(p-V)/(Y-V);N=g.clamp(N,0,1),ts[tI]=new d(T,N),++tI}let b=3*I;for(let t=0;t<b;++t,++tE)tc[tE]=E[Z.getUint16($,!0)],$+=f;if(ti!==$-t)throw new p("Invalid terrain tile.")}ta.length=tI,ts.length=tI,tu.length=tI,_&&(tl.length=tI),Q&&(th.length=tI);let tf=tI,tT=tE,tN={hMin:q,lastBorderPoint:void 0,skirtHeight:M,toENU:J,ellipsoid:m,minimum:k,maximum:P};if(td.sort(function(t,e){return e.cartographic.latitude-t.cartographic.latitude}),tm.sort(function(t,e){return t.cartographic.longitude-e.cartographic.longitude}),tg.sort(function(t,e){return t.cartographic.latitude-e.cartographic.latitude}),tp.sort(function(t,e){return e.cartographic.longitude-t.cartographic.longitude}),F(ta,tu,ts,tl,th,tc,tN,td,-1e-5*L,!0,-1e-5*H),F(ta,tu,ts,tl,th,tc,tN,tm,-1e-5*H,!1),F(ta,tu,ts,tl,th,tc,tN,tg,1e-5*L,!0,1e-5*H),F(ta,tu,ts,tl,th,tc,tN,tp,1e-5*H,!1),td.length>0&&tp.length>0){let t=td[0].index,e=tp[tp.length-1].index,i=ta.length-1;tc.push(e,i,tf,tf,t,e)}tt=ta.length;let tS=a.fromPoints(ta),tx;E(I)&&(tx=o.fromRectangle(I,q,X,m));let tA=new t(m).computeHorizonCullingPointPossiblyUnderEllipsoid(l,ta,q),tR=new r(k,P,l),tB=new e(l,tR,tN.hMin,X,G,!1,_,Q,v,w),tk=new Float32Array(tt*tB.stride),tP=0;for(let t=0;t<tt;++t)tP=tB.encode(tk,tP,ta[t],ts[t],tu[t],void 0,tl[t],th[t]);let tb=td.map(function(t){return t.index}).reverse(),tF=tm.map(function(t){return t.index}).reverse(),ty=tg.map(function(t){return t.index}).reverse(),tv=tp.map(function(t){return t.index}).reverse();return tF.unshift(ty[ty.length-1]),tF.push(tb[0]),tv.unshift(tb[tb.length-1]),tv.push(ty[0]),{vertices:tk,indices:new Uint16Array(tc),maximumHeight:X,minimumHeight:q,encoding:tB,boundingSphere3D:tS,orientedBoundingBox:tx,occludeePointInScaledSpace:tA,vertexCountWithoutSkirts:tf,indexCountWithoutSkirts:tT,westIndicesSouthToNorth:tb,southIndicesEastToWest:tF,eastIndicesNorthToSouth:ty,northIndicesWestToEast:tv}}(i.buffer,i.relativeToCenter,i.ellipsoid,i.rectangle,i.nativeRectangle,i.exaggeration,i.exaggerationRelativeHeight,i.skirtHeight,i.includeWebMercatorT,i.negativeAltitudeExponentBias,i.negativeElevationThreshold),v=y.vertices;I.push(v.buffer);let w=y.indices;return I.push(w.buffer),{vertices:v.buffer,indices:w.buffer,numberOfAttributes:y.encoding.stride,minimumHeight:y.minimumHeight,maximumHeight:y.maximumHeight,boundingSphere3D:y.boundingSphere3D,orientedBoundingBox:y.orientedBoundingBox,occludeePointInScaledSpace:y.occludeePointInScaledSpace,encoding:y.encoding,vertexCountWithoutSkirts:y.vertexCountWithoutSkirts,indexCountWithoutSkirts:y.indexCountWithoutSkirts,westIndicesSouthToNorth:y.westIndicesSouthToNorth,southIndicesEastToWest:y.southIndicesEastToWest,eastIndicesNorthToSouth:y.eastIndicesNorthToSouth,northIndicesWestToEast:y.northIndicesWestToEast}});export{y as default};