import{a as t}from"./chunk-4IMXHKCA.js";import{a as e}from"./chunk-D4TZ3IL5.js";import{a as o}from"./chunk-GHQSI7F2.js";import{a as i}from"./chunk-KM43AUZL.js";import{a as n}from"./chunk-AOALMXNW.js";import"./chunk-CXNPIJLB.js";import"./chunk-APUOR5ZJ.js";import{a as r}from"./chunk-ZFTFDHK4.js";import{a as a}from"./chunk-74GQJJ7R.js";import{a as s}from"./chunk-FNJKWSPR.js";import"./chunk-KSZ5EBRB.js";import{a as l,b as u}from"./chunk-CKMJZ5B3.js";import"./chunk-WNTCOVG2.js";import"./chunk-EEKB62LQ.js";import{a as c,b as h}from"./chunk-V3DSE3OK.js";import"./chunk-FMRIJYNG.js";import{a as p}from"./chunk-NNHN6WUY.js";import"./chunk-T7ERZ2CJ.js";import{c as g,d as m}from"./chunk-GSNDLQ4C.js";import{d as d}from"./chunk-BKSIEBAA.js";import{f as f,h as y}from"./chunk-YWRPWWKI.js";import{a as _}from"./chunk-VTVHUB7E.js";import{a as P,b as T,c as w,d as I,e as O}from"./chunk-JMSSU44E.js";import{a as b}from"./chunk-4UYSGV57.js";import"./chunk-ANLJ4KBN.js";import"./chunk-ID6SFQTL.js";import{a as A}from"./chunk-VLPNAR64.js";import{a as E,b as N}from"./chunk-GE5NEIZC.js";import{e as x}from"./chunk-35CVRQTC.js";function v(t,e){this.position=t,x(this.position)||(this.position=new w),this.tangentPlane=e,x(this.tangentPlane)||(this.tangentPlane=v.NORTH_POLE_TANGENT_PLANE)}Object.defineProperties(v.prototype,{ellipsoid:{get:function(){return this.tangentPlane.ellipsoid}},x:{get:function(){return this.position.x}},y:{get:function(){return this.position.y}},conformalLatitude:{get:function(){let t=w.magnitude(this.position),e=2*this.ellipsoid.maximumRadius;return this.tangentPlane.plane.normal.z*(b.PI_OVER_TWO-2*Math.atan2(t,e))}},longitude:{get:function(){let t=b.PI_OVER_TWO+Math.atan2(this.y,this.x);return t>Math.PI&&(t-=b.TWO_PI),t}}});var H=new T,R=new P;v.prototype.getLatitude=function(t){x(t)||(t=I.default),H.latitude=this.conformalLatitude,H.longitude=this.longitude,H.height=0;let e=this.ellipsoid.cartographicToCartesian(H,R);return t.cartesianToCartographic(e,H),H.latitude};var L=new c,k=new P,C=new P;v.fromCartesian=function(t,e){N.defined("cartesian",t);let o=b.signNotZero(t.z),i=v.NORTH_POLE_TANGENT_PLANE,n=v.SOUTH_POLE;o<0&&(i=v.SOUTH_POLE_TANGENT_PLANE,n=v.NORTH_POLE),L.origin=i.ellipsoid.scaleToGeocentricSurface(t,L.origin),L.direction=P.subtract(L.origin,n,k),P.normalize(L.direction,L.direction);let r=h.rayPlane(L,i.plane,C),a=P.subtract(r,n,r),s=P.dot(i.xAxis,a),l=o*P.dot(i.yAxis,a);return x(e)?(e.position=new w(s,l),e.tangentPlane=i,e):new v(new w(s,l),i)},v.fromCartesianArray=function(t,e){N.defined("cartesians",t);let o=t.length;x(e)?e.length=o:e=Array(o);for(let i=0;i<o;i++)e[i]=v.fromCartesian(t[i],e[i]);return e},v.clone=function(t,e){if(x(t))return x(e)?(e.position=t.position,e.tangentPlane=t.tangentPlane,e):new v(t.position,t.tangentPlane)},v.HALF_UNIT_SPHERE=Object.freeze(new I(.5,.5,.5)),v.NORTH_POLE=Object.freeze(new P(0,0,.5)),v.SOUTH_POLE=Object.freeze(new P(0,0,-.5)),v.NORTH_POLE_TANGENT_PLANE=Object.freeze(new s(v.NORTH_POLE,v.HALF_UNIT_SPHERE)),v.SOUTH_POLE_TANGENT_PLANE=Object.freeze(new s(v.SOUTH_POLE,v.HALF_UNIT_SPHERE));var j=new T,F=new T,S=new t,G=new P,V=new P,B=new P,M=new P,U=new P,W=new P,z=new P,D=new P,Y=new P,K=new w,J=new w,Z=new P,Q=new f,q=new O,X=new O;function $(t){let e=t.vertexFormat,o=t.geometry,i=t.shadowVolume,n=o.attributes.position.values,a=x(o.attributes.st)?o.attributes.st.values:void 0,s=n.length,l=t.wall,u=t.top||l,c=t.bottom||l;if(e.st||e.normal||e.tangent||e.bitangent||i){let r=t.boundingRectangle,h=t.rotationAxis,p=t.projectTo2d,g=t.ellipsoid,d=t.stRotation,y=t.perPositionHeight;K.x=r.x,K.y=r.y;let T=e.st?new Float32Array(s/3*2):void 0,I;e.normal&&(I=y&&u&&!l?o.attributes.normal.values:new Float32Array(s));let A=e.tangent?new Float32Array(s):void 0,E=e.bitangent?new Float32Array(s):void 0,N=i?new Float32Array(s):void 0,v=0,H=0,R=V,L=B,k=M,C=!0,S=q,$=X;if(0!==d){let t=f.fromAxisAngle(h,d,Q);S=O.fromQuaternion(t,S),t=f.fromAxisAngle(h,-d,Q),$=O.fromQuaternion(t,$)}else S=O.clone(O.IDENTITY,S),$=O.clone(O.IDENTITY,$);let tt=0,te=0;u&&c&&(tt=s/2,te=s/3,s/=2);for(let o=0;o<s;o+=3){let h=P.fromArray(n,o,Z);if(e.st&&!x(a)){let t=O.multiplyByVector(S,h,G),e=p([t=g.scaleToGeodeticSurface(t,t)],J)[0];w.subtract(e,K,e);let o=b.clamp(e.x/r.width,0,1),i=b.clamp(e.y/r.height,0,1);c&&(T[v+te]=o,T[v+1+te]=i),u&&(T[v]=o,T[v+1]=i),v+=2}if(e.normal||e.tangent||e.bitangent||i){let r=H+1,a=H+2;if(l){if(o+3<s){let t=P.fromArray(n,o+3,U);if(C){let e=P.fromArray(n,o+s,W);y&&function(t,e,o,i){let n=i.cartesianToCartographic(t,j).height,r=i.cartesianToCartographic(e,F);r.height=n,i.cartographicToCartesian(r,e);let a=i.cartesianToCartographic(o,F);a.height=n-100,i.cartographicToCartesian(a,o)}(h,t,e,g),P.subtract(t,h,t),P.subtract(e,h,e),R=P.normalize(P.cross(e,t,R),R),C=!1}P.equalsEpsilon(t,h,b.EPSILON10)&&(C=!0)}(e.tangent||e.bitangent)&&(k=g.geodeticSurfaceNormal(h,k),e.tangent&&(L=P.normalize(P.cross(k,R,L),L)))}else R=g.geodeticSurfaceNormal(h,R),(e.tangent||e.bitangent)&&(y&&(z=P.fromArray(I,H,z),D=P.cross(P.UNIT_Z,z,D),D=P.normalize(O.multiplyByVector($,D,D),D),e.bitangent&&(Y=P.normalize(P.cross(z,D,Y),Y))),L=P.cross(P.UNIT_Z,R,L),L=P.normalize(O.multiplyByVector($,L,L),L),e.bitangent&&(k=P.normalize(P.cross(R,L,k),k)));e.normal&&(t.wall?(I[H+tt]=R.x,I[r+tt]=R.y,I[a+tt]=R.z):c&&(I[H+tt]=-R.x,I[r+tt]=-R.y,I[a+tt]=-R.z),(u&&!y||l)&&(I[H]=R.x,I[r]=R.y,I[a]=R.z)),i&&(l&&(R=g.geodeticSurfaceNormal(h,R)),N[H+tt]=-R.x,N[r+tt]=-R.y,N[a+tt]=-R.z),e.tangent&&(t.wall?(A[H+tt]=L.x,A[r+tt]=L.y,A[a+tt]=L.z):c&&(A[H+tt]=-L.x,A[r+tt]=-L.y,A[a+tt]=-L.z),u&&(y?(A[H]=D.x,A[r]=D.y,A[a]=D.z):(A[H]=L.x,A[r]=L.y,A[a]=L.z))),e.bitangent&&(c&&(E[H+tt]=k.x,E[r+tt]=k.y,E[a+tt]=k.z),u&&(y?(E[H]=Y.x,E[r]=Y.y,E[a]=Y.z):(E[H]=k.x,E[r]=k.y,E[a]=k.z))),H+=3}}e.st&&!x(a)&&(o.attributes.st=new m({componentDatatype:_.FLOAT,componentsPerAttribute:2,values:T})),e.normal&&(o.attributes.normal=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:I})),e.tangent&&(o.attributes.tangent=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:A})),e.bitangent&&(o.attributes.bitangent=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:E})),i&&(o.attributes.extrudeDirection=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:N}))}if(t.extrude&&x(t.offsetAttribute)){let e=n.length/3,i=new Uint8Array(e);if(t.offsetAttribute===r.TOP)u&&c||l?i=i.fill(1,0,e/2):u&&(i=i.fill(1));else{let e=+(t.offsetAttribute!==r.NONE);i=i.fill(e)}o.attributes.applyOffset=new m({componentDatatype:_.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}return o}var tt=[];function te(t){if(N.typeOf.object("options",t),N.typeOf.object("options.polygonHierarchy",t.polygonHierarchy),x(t.perPositionHeight)&&t.perPositionHeight&&x(t.height))throw new E("Cannot use both options.perPositionHeight and options.height");if(x(t.arcType)&&t.arcType!==o.GEODESIC&&t.arcType!==o.RHUMB)throw new E("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");let i=t.polygonHierarchy,n=A(t.vertexFormat,a.DEFAULT),r=A(t.ellipsoid,I.default),s=A(t.granularity,b.RADIANS_PER_DEGREE),l=A(t.stRotation,0),u=t.textureCoordinates,c=A(t.perPositionHeight,!1),h=c&&x(t.extrudedHeight),p=A(t.height,0),g=A(t.extrudedHeight,p);if(!h){let t=Math.max(p,g);g=Math.min(p,g),p=t}this._vertexFormat=a.clone(n),this._ellipsoid=I.clone(r),this._granularity=s,this._stRotation=l,this._height=p,this._extrudedHeight=g,this._closeTop=A(t.closeTop,!0),this._closeBottom=A(t.closeBottom,!0),this._polygonHierarchy=i,this._perPositionHeight=c,this._perPositionHeightExtrude=h,this._shadowVolume=A(t.shadowVolume,!1),this._workerName="createPolygonGeometry",this._offsetAttribute=t.offsetAttribute,this._arcType=A(t.arcType,o.GEODESIC),this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this._textureCoordinates=u,this.packedLength=e.computeHierarchyPackedLength(i,P)+I.packedLength+a.packedLength+(u?e.computeHierarchyPackedLength(u,w):1)+12}te.fromPositions=function(t){return t=A(t,A.EMPTY_OBJECT),N.defined("options.positions",t.positions),new te({polygonHierarchy:{positions:t.positions},height:t.height,extrudedHeight:t.extrudedHeight,vertexFormat:t.vertexFormat,stRotation:t.stRotation,ellipsoid:t.ellipsoid,granularity:t.granularity,perPositionHeight:t.perPositionHeight,closeTop:t.closeTop,closeBottom:t.closeBottom,offsetAttribute:t.offsetAttribute,arcType:t.arcType,textureCoordinates:t.textureCoordinates})},te.pack=function(t,o,i){return N.typeOf.object("value",t),N.defined("array",o),i=A(i,0),i=e.packPolygonHierarchy(t._polygonHierarchy,o,i,P),I.pack(t._ellipsoid,o,i),i+=I.packedLength,a.pack(t._vertexFormat,o,i),i+=a.packedLength,o[i++]=t._height,o[i++]=t._extrudedHeight,o[i++]=t._granularity,o[i++]=t._stRotation,o[i++]=+!!t._perPositionHeightExtrude,o[i++]=+!!t._perPositionHeight,o[i++]=+!!t._closeTop,o[i++]=+!!t._closeBottom,o[i++]=+!!t._shadowVolume,o[i++]=A(t._offsetAttribute,-1),o[i++]=t._arcType,x(t._textureCoordinates)?i=e.packPolygonHierarchy(t._textureCoordinates,o,i,w):o[i++]=-1,o[i++]=t.packedLength,o};var to=I.clone(I.UNIT_SPHERE),ti=new a,tn={polygonHierarchy:{}};te.unpack=function(t,o,i){N.defined("array",t),o=A(o,0);let n=e.unpackPolygonHierarchy(t,o,P);o=n.startingIndex,delete n.startingIndex;let r=I.unpack(t,o,to);o+=I.packedLength;let s=a.unpack(t,o,ti);o+=a.packedLength;let l=t[o++],u=t[o++],c=t[o++],h=t[o++],p=1===t[o++],g=1===t[o++],m=1===t[o++],d=1===t[o++],f=1===t[o++],y=t[o++],_=t[o++],T=-1===t[o]?void 0:e.unpackPolygonHierarchy(t,o,w);x(T)?(o=T.startingIndex,delete T.startingIndex):o++;let O=t[o++];return x(i)||(i=new te(tn)),i._polygonHierarchy=n,i._ellipsoid=I.clone(r,i._ellipsoid),i._vertexFormat=a.clone(s,i._vertexFormat),i._height=l,i._extrudedHeight=u,i._granularity=c,i._stRotation=h,i._perPositionHeightExtrude=p,i._perPositionHeight=g,i._closeTop=m,i._closeBottom=d,i._shadowVolume=f,i._offsetAttribute=-1===y?void 0:y,i._arcType=_,i._textureCoordinates=T,i.packedLength=O,i};var tr=new w,ta=new w,ts=new v;function tl(t,e,i,n,r,a){let s=t.longitude,l=s>=0?s:s+b.TWO_PI;r.westOverIdl=Math.min(r.westOverIdl,l),r.eastOverIdl=Math.max(r.eastOverIdl,l),a.west=Math.min(a.west,s),a.east=Math.max(a.east,s);let u=t.getLatitude(i),c=u;if(a.south=Math.min(a.south,u),a.north=Math.max(a.north,u),n!==o.RHUMB){let o=w.subtract(e.position,t.position,tr),n=w.dot(e.position,o)/w.dot(o,o);if(n>0&&n<1){let t=w.add(e.position,w.multiplyByScalar(o,-n,o),ta),r=v.clone(e,ts);r.position=t;let s=r.getLatitude(i);a.south=Math.min(a.south,s),a.north=Math.max(a.north,s),Math.abs(u)>Math.abs(s)&&(c=s)}}let h=Math.sign(e.x*t.y-t.x*e.y);0!==h&&(h*=w.angleBetween(e.position,t.position)),c>=0&&(r.northAngle+=h),c<=0&&(r.southAngle+=h)}var tu=new v,tc=new v,th={northAngle:0,southAngle:0,westOverIdl:0,eastOverIdl:0};te.computeRectangleFromPositions=function(t,e,o,i){if(N.defined("positions",t),x(i)||(i=new y),t.length<3)return i;i.west=Number.POSITIVE_INFINITY,i.east=Number.NEGATIVE_INFINITY,i.south=Number.POSITIVE_INFINITY,i.north=Number.NEGATIVE_INFINITY,th.northAngle=0,th.southAngle=0,th.westOverIdl=Number.POSITIVE_INFINITY,th.eastOverIdl=Number.NEGATIVE_INFINITY;let n=t.length,r=v.fromCartesian(t[0],tc);for(let a=1;a<n;a++){let n=v.fromCartesian(t[a],tu);tl(n,r,e,o,th,i),r=v.clone(n,r)}return tl(v.fromCartesian(t[0],tu),r,e,o,th,i),i.east-i.west>th.eastOverIdl-th.westOverIdl&&(i.west=th.westOverIdl,i.east=th.eastOverIdl,i.east>b.PI&&(i.east=i.east-b.TWO_PI),i.west>b.PI&&(i.west=i.west-b.TWO_PI)),b.equalsEpsilon(Math.abs(th.northAngle),b.TWO_PI,b.EPSILON10)&&(i.north=b.PI_OVER_TWO,i.east=b.PI,i.west=-b.PI),b.equalsEpsilon(Math.abs(th.southAngle),b.TWO_PI,b.EPSILON10)&&(i.south=-b.PI_OVER_TWO,i.east=b.PI,i.west=-b.PI),i};var tp=new v,tg=new T;te.createGeometry=function(o){let a=o._vertexFormat,c=o._ellipsoid,h=o._granularity,f=o._stRotation,y=o._polygonHierarchy,P=o._perPositionHeight,T=o._closeTop,I=o._closeBottom,O=o._arcType,A=o._textureCoordinates,E=x(A),N=y.positions;if(N.length<3)return;let H=o.rectangle,R=e.polygonsFromHierarchy(y,E,(t,e)=>{if(H.height>=b.PI||H.width>=b.PI){if(H.south<0&&H.north>0){x(e)||(e=[]);for(let o=0;o<t.length;++o){let i=c.cartesianToCartographic(t[o],tg);e[o]=new w(i.longitude/b.PI,i.latitude/b.PI_OVER_TWO)}return e.length=t.length,e}return v.fromCartesianArray(t,e)}return s.fromPoints(N,c).projectPointsOntoPlane(t,e)},!P,c,(t,o)=>!P&&(H.height>=b.PI_OVER_TWO||H.width>=2*b.PI_OVER_THREE)?e.splitPolygonsOnEquator(t,c,O,o):t),L=R.hierarchy,k=R.polygons,C=E?e.polygonsFromHierarchy(A,!0,function(t){return t},!1,c).polygons:void 0;if(0===L.length)return;let j=L[0].outerRing,F=function(o,i,n,r){if(i.height>=b.PI||i.width>=b.PI)return t.fromRectangle(i,void 0,S);let a=s.fromPoints(o,n);return e.computeBoundingRectangle(a.plane.normal,a.projectPointOntoPlane.bind(a),o,r,S)}(j,H,c,f),G=[],V=o._height,B=o._extrudedHeight,M=o._perPositionHeightExtrude||!b.equalsEpsilon(V,B,0,b.EPSILON2),U={perPositionHeight:P,vertexFormat:a,geometry:void 0,rotationAxis:(H.height>=b.PI||H.width>=b.PI?v.fromCartesian(j[0],tp).tangentPlane:s.fromPoints(j,c)).plane.normal,projectTo2d:function(t,e,o){if(t.height>=b.PI||t.width>=b.PI)return(e,i)=>{if(t.south<0&&t.north>0){let t=o.cartesianToCartographic(e,tg);return x(i)||(i=new w),i.x=t.longitude/b.PI,i.y=t.latitude/b.PI_OVER_TWO,i}return v.fromCartesian(e,i)};let i=s.fromPoints(e,o);return(t,e)=>i.projectPointsOntoPlane(t,e)}(H,j,c),boundingRectangle:F,ellipsoid:c,stRotation:f,textureCoordinates:void 0,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:O},W;if(M)for(U.extrude=!0,U.top=T,U.bottom=I,U.shadowVolume=o._shadowVolume,U.offsetAttribute=o._offsetAttribute,W=0;W<k.length;W++){let t=function(t,o,n,r,a,c,h,g,m,d){let f={walls:[]},y;if(h||g){let a=e.createGeometryFromPositions(t,o,n,r,c,m,d),s=a.attributes.position.values,l=a.indices,u,_;if(h&&g){let t=s.concat(s);u=t.length/3,(_=p.createTypedArray(u,2*l.length)).set(l);let e=l.length,o=u/2;for(y=0;y<e;y+=3){let t=_[y]+o,i=_[y+1]+o,n=_[y+2]+o;_[y+e]=n,_[y+1+e]=i,_[y+2+e]=t}if(a.attributes.position.values=t,c&&m.normal){let e=a.attributes.normal.values;a.attributes.normal.values=new Float32Array(t.length),a.attributes.normal.values.set(e)}if(m.st&&x(n)){let t=a.attributes.st.values;a.attributes.st.values=new Float32Array(2*u),a.attributes.st.values=t.concat(t)}a.indices=_}else if(g){for(u=s.length/3,_=p.createTypedArray(u,l.length),y=0;y<l.length;y+=3)_[y]=l[y+2],_[y+1]=l[y+1],_[y+2]=l[y];a.indices=_}f.topAndBottom=new i({geometry:a})}let _=a.outerRing,P=s.fromPoints(_,t),T=P.projectPointsOntoPlane(_,tt),w=u.computeWindingOrder2D(T);w===l.CLOCKWISE&&(_=_.slice().reverse());let I=e.computeWallGeometry(_,n,t,r,c,d);f.walls.push(new i({geometry:I}));let O=a.holes;for(y=0;y<O.length;y++){let o=O[y];T=P.projectPointsOntoPlane(o,tt),(w=u.computeWindingOrder2D(T))===l.COUNTER_CLOCKWISE&&(o=o.slice().reverse()),I=e.computeWallGeometry(o,n,t,r,c,d),f.walls.push(new i({geometry:I}))}return f}(c,k[W],E?C[W]:void 0,h,L[W],P,T,I,a,O),o;T&&I?(o=t.topAndBottom,U.geometry=e.scaleToGeodeticHeightExtruded(o.geometry,V,B,c,P)):T?((o=t.topAndBottom).geometry.attributes.position.values=u.scaleToGeodeticHeight(o.geometry.attributes.position.values,V,c,!P),U.geometry=o.geometry):I&&((o=t.topAndBottom).geometry.attributes.position.values=u.scaleToGeodeticHeight(o.geometry.attributes.position.values,B,c,!0),U.geometry=o.geometry),(T||I)&&(U.wall=!1,o.geometry=$(U),G.push(o));let n=t.walls;U.wall=!0;for(let t=0;t<n.length;t++){let o=n[t];U.geometry=e.scaleToGeodeticHeightExtruded(o.geometry,V,B,c,P),o.geometry=$(U),G.push(o)}}else for(W=0;W<k.length;W++){let t=new i({geometry:e.createGeometryFromPositions(c,k[W],E?C[W]:void 0,h,P,a,O)});if(t.geometry.attributes.position.values=u.scaleToGeodeticHeight(t.geometry.attributes.position.values,V,c,!P),U.geometry=t.geometry,t.geometry=$(U),x(o._offsetAttribute)){let e=t.geometry.attributes.position.values.length,i=+(o._offsetAttribute!==r.NONE),n=new Uint8Array(e/3).fill(i);t.geometry.attributes.applyOffset=new m({componentDatatype:_.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}G.push(t)}let z=n.combineInstances(G)[0];z.attributes.position.values=new Float64Array(z.attributes.position.values),z.indices=p.createTypedArray(z.attributes.position.values.length/3,z.indices);let D=z.attributes,Y=d.fromVertices(D.position.values);return a.position||delete D.position,new g({attributes:D,indices:z.indices,primitiveType:z.primitiveType,boundingSphere:Y,offsetAttribute:o._offsetAttribute})},te.createShadowVolume=function(t,e,o){let i=t._granularity,n=t._ellipsoid,r=e(i,n),s=o(i,n);return new te({polygonHierarchy:t._polygonHierarchy,ellipsoid:n,stRotation:t._stRotation,granularity:i,perPositionHeight:!1,extrudedHeight:r,height:s,vertexFormat:a.POSITION_ONLY,shadowVolume:!0,arcType:t._arcType})},Object.defineProperties(te.prototype,{rectangle:{get:function(){if(!x(this._rectangle)){let t=this._polygonHierarchy.positions;this._rectangle=te.computeRectangleFromPositions(t,this._ellipsoid,this._arcType)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return x(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){let e=-t._stRotation;if(0===e)return[0,0,0,1,1,0];let o=t._ellipsoid,i=t._polygonHierarchy.positions,n=t.rectangle;return g._textureCoordinateRotationPoints(i,e,o,n)}(this)),this._textureCoordinateRotationPoints}}});var tm=function(t,e){return x(e)&&(t=te.unpack(t,e)),t._ellipsoid=I.clone(t._ellipsoid),te.createGeometry(t)};export{tm as default};