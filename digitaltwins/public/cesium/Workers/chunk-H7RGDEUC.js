import{a as i}from"./chunk-ZFTFDHK4.js";import{a as t}from"./chunk-NNHN6WUY.js";import{a as o}from"./chunk-T7ERZ2CJ.js";import{b as e,c as r,d as n}from"./chunk-GSNDLQ4C.js";import{d as a}from"./chunk-BKSIEBAA.js";import{a as s}from"./chunk-VTVHUB7E.js";import{a as m,d as u}from"./chunk-JMSSU44E.js";import{a as f}from"./chunk-4UYSGV57.js";import{a as c}from"./chunk-VLPNAR64.js";import{a as l}from"./chunk-GE5NEIZC.js";import{e as d}from"./chunk-35CVRQTC.js";var h=new m(1,1,1),_=Math.cos,k=Math.sin;function p(t){t=c(t,c.EMPTY_OBJECT);let o=c(t.radii,h),e=c(t.innerRadii,o),r=c(t.minimumClock,0),n=c(t.maximumClock,f.TWO_PI),a=c(t.minimumCone,0),s=c(t.maximumCone,f.PI),u=Math.round(c(t.stackPartitions,10)),_=Math.round(c(t.slicePartitions,8)),k=Math.round(c(t.subdivisions,128));if(u<1)throw new l("options.stackPartitions cannot be less than 1");if(_<0)throw new l("options.slicePartitions cannot be less than 0");if(k<0)throw new l("options.subdivisions must be greater than or equal to zero.");if(d(t.offsetAttribute)&&t.offsetAttribute===i.TOP)throw new l("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._radii=m.clone(o),this._innerRadii=m.clone(e),this._minimumClock=r,this._maximumClock=n,this._minimumCone=a,this._maximumCone=s,this._stackPartitions=u,this._slicePartitions=_,this._subdivisions=k,this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidOutlineGeometry"}p.packedLength=2*m.packedLength+8,p.pack=function(i,t,o){if(!d(i))throw new l("value is required");if(!d(t))throw new l("array is required");return o=c(o,0),m.pack(i._radii,t,o),o+=m.packedLength,m.pack(i._innerRadii,t,o),o+=m.packedLength,t[o++]=i._minimumClock,t[o++]=i._maximumClock,t[o++]=i._minimumCone,t[o++]=i._maximumCone,t[o++]=i._stackPartitions,t[o++]=i._slicePartitions,t[o++]=i._subdivisions,t[o]=c(i._offsetAttribute,-1),t};var C=new m,b=new m,P={radii:C,innerRadii:b,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,subdivisions:void 0,offsetAttribute:void 0};p.unpack=function(i,t,o){if(!d(i))throw new l("array is required");t=c(t,0);let e=m.unpack(i,t,C);t+=m.packedLength;let r=m.unpack(i,t,b);t+=m.packedLength;let n=i[t++],a=i[t++],s=i[t++],u=i[t++],f=i[t++],h=i[t++],_=i[t++],k=i[t];return d(o)?(o._radii=m.clone(e,o._radii),o._innerRadii=m.clone(r,o._innerRadii),o._minimumClock=n,o._maximumClock=a,o._minimumCone=s,o._maximumCone=u,o._stackPartitions=f,o._slicePartitions=h,o._subdivisions=_,o._offsetAttribute=-1===k?void 0:k,o):(P.minimumClock=n,P.maximumClock=a,P.minimumCone=s,P.maximumCone=u,P.stackPartitions=f,P.slicePartitions=h,P.subdivisions=_,P.offsetAttribute=-1===k?void 0:k,new p(P))},p.createGeometry=function(m){let c=m._radii;if(c.x<=0||c.y<=0||c.z<=0)return;let l=m._innerRadii;if(l.x<=0||l.y<=0||l.z<=0)return;let h=m._minimumClock,p=m._maximumClock,C=m._minimumCone,b=m._maximumCone,P=m._subdivisions,y=u.fromCartesian3(c),A=m._slicePartitions+1,v=m._stackPartitions+1;A=Math.round(A*Math.abs(p-h)/f.TWO_PI),v=Math.round(v*Math.abs(b-C)/f.PI),A<2&&(A=2),v<2&&(v=2);let w=0,x=1,E=l.x!==c.x||l.y!==c.y||l.z!==c.z,g=!1,T=!1;E&&(x=2,C>0&&(g=!0,w+=A),b<Math.PI&&(T=!0,w+=A));let M=P*x*(v+A),N=new Float64Array(3*M),j=2*(M+w-(A+v)*x),L=t.createTypedArray(M,j),O,R,z,I,S=0,G=Array(v),U=Array(v);for(O=0;O<v;O++)I=C+O*(b-C)/(v-1),G[O]=k(I),U[O]=_(I);let B=Array(P),D=Array(P);for(O=0;O<P;O++)z=h+O*(p-h)/(P-1),B[O]=k(z),D[O]=_(z);for(O=0;O<v;O++)for(R=0;R<P;R++)N[S++]=c.x*G[O]*D[R],N[S++]=c.y*G[O]*B[R],N[S++]=c.z*U[O];if(E)for(O=0;O<v;O++)for(R=0;R<P;R++)N[S++]=l.x*G[O]*D[R],N[S++]=l.y*G[O]*B[R],N[S++]=l.z*U[O];for(G.length=P,U.length=P,O=0;O<P;O++)I=C+O*(b-C)/(P-1),G[O]=k(I),U[O]=_(I);for(B.length=A,D.length=A,O=0;O<A;O++)z=h+O*(p-h)/(A-1),B[O]=k(z),D[O]=_(z);for(O=0;O<P;O++)for(R=0;R<A;R++)N[S++]=c.x*G[O]*D[R],N[S++]=c.y*G[O]*B[R],N[S++]=c.z*U[O];if(E)for(O=0;O<P;O++)for(R=0;R<A;R++)N[S++]=l.x*G[O]*D[R],N[S++]=l.y*G[O]*B[R],N[S++]=l.z*U[O];for(S=0,O=0;O<v*x;O++){let i=O*P;for(R=0;R<P-1;R++)L[S++]=i+R,L[S++]=i+R+1}let V=v*P*x;for(O=0;O<A;O++)for(R=0;R<P-1;R++)L[S++]=V+O+R*A,L[S++]=V+O+(R+1)*A;if(E)for(V=v*P*x+A*P,O=0;O<A;O++)for(R=0;R<P-1;R++)L[S++]=V+O+R*A,L[S++]=V+O+(R+1)*A;if(E){let i=v*P*x,t=i+P*A;if(g)for(O=0;O<A;O++)L[S++]=i+O,L[S++]=t+O;if(T)for(i+=P*A-A,t+=P*A-A,O=0;O<A;O++)L[S++]=i+O,L[S++]=t+O}let q=new o({position:new n({componentDatatype:s.DOUBLE,componentsPerAttribute:3,values:N})});if(d(m._offsetAttribute)){let t=N.length,o=+(m._offsetAttribute!==i.NONE),e=new Uint8Array(t/3).fill(o);q.applyOffset=new n({componentDatatype:s.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}return new r({attributes:q,indices:L,primitiveType:e.LINES,boundingSphere:a.fromEllipsoid(y),offsetAttribute:m._offsetAttribute})};var y=p;export{y as a};