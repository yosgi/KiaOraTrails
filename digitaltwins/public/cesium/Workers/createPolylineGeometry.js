import{a as e}from"./chunk-JS6PT4NQ.js";import{a as t}from"./chunk-GHQSI7F2.js";import{a as r}from"./chunk-M5SITFFN.js";import"./chunk-ZPYKVVFF.js";import{a as o}from"./chunk-74GQJJ7R.js";import{a as n}from"./chunk-WNTCOVG2.js";import"./chunk-EEKB62LQ.js";import"./chunk-V3DSE3OK.js";import"./chunk-FMRIJYNG.js";import{a as a}from"./chunk-NNHN6WUY.js";import{a as i}from"./chunk-T7ERZ2CJ.js";import{a as s,b as l,c as c,d as p}from"./chunk-GSNDLQ4C.js";import{d as h}from"./chunk-BKSIEBAA.js";import"./chunk-YWRPWWKI.js";import{a as u}from"./chunk-VTVHUB7E.js";import{a as m,d as d}from"./chunk-JMSSU44E.js";import{a as f}from"./chunk-4UYSGV57.js";import"./chunk-ANLJ4KBN.js";import"./chunk-ID6SFQTL.js";import{a as k}from"./chunk-VLPNAR64.js";import{a as g}from"./chunk-GE5NEIZC.js";import{e as y}from"./chunk-35CVRQTC.js";var w=[];function _(r){let n=(r=k(r,k.EMPTY_OBJECT)).positions,a=r.colors,i=k(r.width,1),s=k(r.colorsPerVertex,!1);if(!y(n)||n.length<2)throw new g("At least two positions are required.");if("number"!=typeof i)throw new g("width must be a number");if(y(a)&&(s&&a.length<n.length||!s&&a.length<n.length-1))throw new g("colors has an invalid length.");this._positions=n,this._colors=a,this._width=i,this._colorsPerVertex=s,this._vertexFormat=o.clone(k(r.vertexFormat,o.DEFAULT)),this._arcType=k(r.arcType,t.GEODESIC),this._granularity=k(r.granularity,f.RADIANS_PER_DEGREE),this._ellipsoid=d.clone(k(r.ellipsoid,d.default)),this._workerName="createPolylineGeometry";let l=1+n.length*m.packedLength;l+=y(a)?1+a.length*e.packedLength:1,this.packedLength=l+d.packedLength+o.packedLength+4}_.pack=function(t,r,n){if(!y(t))throw new g("value is required");if(!y(r))throw new g("array is required");n=k(n,0);let a,i=t._positions,s=i.length;for(r[n++]=s,a=0;a<s;++a,n+=m.packedLength)m.pack(i[a],r,n);let l=t._colors;for(s=y(l)?l.length:0,r[n++]=s,a=0;a<s;++a,n+=e.packedLength)e.pack(l[a],r,n);return d.pack(t._ellipsoid,r,n),n+=d.packedLength,o.pack(t._vertexFormat,r,n),n+=o.packedLength,r[n++]=t._width,r[n++]=+!!t._colorsPerVertex,r[n++]=t._arcType,r[n]=t._granularity,r};var E=d.clone(d.UNIT_SPHERE),v=new o,A={positions:void 0,colors:void 0,ellipsoid:E,vertexFormat:v,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};_.unpack=function(t,r,n){if(!y(t))throw new g("array is required");r=k(r,0);let a,i=t[r++],s=Array(i);for(a=0;a<i;++a,r+=m.packedLength)s[a]=m.unpack(t,r);let l=(i=t[r++])>0?Array(i):void 0;for(a=0;a<i;++a,r+=e.packedLength)l[a]=e.unpack(t,r);let c=d.unpack(t,r,E);r+=d.packedLength;let p=o.unpack(t,r,v);r+=o.packedLength;let h=t[r++],u=1===t[r++],f=t[r++],w=t[r];return y(n)?(n._positions=s,n._colors=l,n._ellipsoid=d.clone(c,n._ellipsoid),n._vertexFormat=o.clone(p,n._vertexFormat),n._width=h,n._colorsPerVertex=u,n._arcType=f,n._granularity=w,n):(A.positions=s,A.colors=l,A.width=h,A.colorsPerVertex=u,A.arcType=f,A.granularity=w,new _(A))};var L=new m,T=new m,P=new m,j=new m;_.createGeometry=function(o){let d=o._width,k=o._vertexFormat,g=o._colors,_=o._colorsPerVertex,E=o._arcType,v=o._granularity,A=o._ellipsoid,F,b,D,x=[],S=n(o._positions,m.equalsEpsilon,!1,x);if(y(g)&&x.length>0){let e=0,t=x[0];g=g.filter(function(r,o){let n=!1;return!(_?o===t||0===o&&1===t:o+1===t)||(t=x[++e],!1)})}let N=S.length;if(N<2||d<=0)return;if(E===t.GEODESIC||E===t.RHUMB){let o,n;E===t.GEODESIC?(o=f.chordLength(v,A.maximumRadius),n=r.numberOfPoints):(o=v,n=r.numberOfPointsRhumbLine);let a=r.extractHeights(S,A);if(y(g)){let t=1;for(F=0;F<N-1;++F)t+=n(S[F],S[F+1],o);let r=Array(t),a=0;for(F=0;F<N-1;++F){let i=S[F],s=S[F+1],l=g[F],c=n(i,s,o);if(_&&F<t){let t=function(t,r,o,n,a){w.length=a;let i,s=o.red,l=o.green,c=o.blue,p=o.alpha,h=n.red,u=n.green,m=n.blue,d=n.alpha;if(e.equals(o,n)){for(i=0;i<a;i++)w[i]=e.clone(o);return w}let f=(h-s)/a,k=(u-l)/a,g=(m-c)/a,y=(d-p)/a;for(i=0;i<a;i++)w[i]=new e(s+i*f,l+i*k,c+i*g,p+i*y);return w}(0,0,l,g[F+1],c),o=t.length;for(b=0;b<o;++b)r[a++]=t[b]}else for(b=0;b<c;++b)r[a++]=e.clone(l)}r[a]=e.clone(g[g.length-1]),g=r,w.length=0}S=E===t.GEODESIC?r.generateCartesianArc({positions:S,minDistance:o,ellipsoid:A,height:a}):r.generateCartesianRhumbArc({positions:S,granularity:o,ellipsoid:A,height:a})}let G=4*(N=S.length)-4,I=new Float64Array(3*G),V=new Float64Array(3*G),B=new Float64Array(3*G),O=new Float32Array(2*G),R=k.st?new Float32Array(2*G):void 0,C=y(g)?new Uint8Array(4*G):void 0,U=0,J=0,Y=0,Q=0,W;for(b=0;b<N;++b){let t,r;0===b?(W=L,m.subtract(S[0],S[1],W),m.add(S[0],W,W)):W=S[b-1],m.clone(W,P),m.clone(S[b],T),b===N-1?(W=L,m.subtract(S[N-1],S[N-2],W),m.add(S[N-1],W,W)):W=S[b+1],m.clone(W,j),y(C)&&(t=0===b||_?g[b]:g[b-1],b!==N-1&&(r=g[b]));let o=2*(0===b),n=b===N-1?2:4;for(D=o;D<n;++D){m.pack(T,I,U),m.pack(P,V,U),m.pack(j,B,U),U+=3;let o=D-2<0?-1:1;if(O[J++]=D%2*2-1,O[J++]=o*d,k.st&&(R[Y++]=b/(N-1),R[Y++]=Math.max(O[J-2],0)),y(C)){let o=D<2?t:r;C[Q++]=e.floatToByte(o.red),C[Q++]=e.floatToByte(o.green),C[Q++]=e.floatToByte(o.blue),C[Q++]=e.floatToByte(o.alpha)}}}let q=new i;q.position=new p({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:I}),q.prevPosition=new p({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:V}),q.nextPosition=new p({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:B}),q.expandAndWidth=new p({componentDatatype:u.FLOAT,componentsPerAttribute:2,values:O}),k.st&&(q.st=new p({componentDatatype:u.FLOAT,componentsPerAttribute:2,values:R})),y(C)&&(q.color=new p({componentDatatype:u.UNSIGNED_BYTE,componentsPerAttribute:4,values:C,normalize:!0}));let H=a.createTypedArray(G,6*N-6),K=0,M=0,Z=N-1;for(b=0;b<Z;++b)H[M++]=K,H[M++]=K+2,H[M++]=K+1,H[M++]=K+1,H[M++]=K+2,H[M++]=K+3,K+=4;return new c({attributes:q,indices:H,primitiveType:l.TRIANGLES,boundingSphere:h.fromPoints(S),geometryType:s.POLYLINES})};var F=function(e,t){return y(t)&&(e=_.unpack(e,t)),e._ellipsoid=d.clone(e._ellipsoid),_.createGeometry(e)};export{F as default};