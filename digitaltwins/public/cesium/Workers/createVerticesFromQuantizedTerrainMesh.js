import{a as t,b as e}from"./chunk-AZ3SWEDV.js";import{a as r}from"./chunk-PWAJ3RAI.js";import{a as i}from"./chunk-R3AL5FUL.js";import"./chunk-CXNPIJLB.js";import{a as n}from"./chunk-KSZ5EBRB.js";import{a as o}from"./chunk-NNHN6WUY.js";import"./chunk-BKSIEBAA.js";import{b as a,g as s,h as h}from"./chunk-YWRPWWKI.js";import"./chunk-VTVHUB7E.js";import{a as u,b as c,c as l,d as I}from"./chunk-JMSSU44E.js";import{a as d}from"./chunk-4UYSGV57.js";import"./chunk-ANLJ4KBN.js";import"./chunk-ID6SFQTL.js";import"./chunk-VLPNAR64.js";import{a as m}from"./chunk-GE5NEIZC.js";import{e as g}from"./chunk-35CVRQTC.js";function T(){m.throwInstantiationError()}Object.defineProperties(T.prototype,{errorEvent:{get:m.throwInstantiationError},credit:{get:m.throwInstantiationError},tilingScheme:{get:m.throwInstantiationError},hasWaterMask:{get:m.throwInstantiationError},hasVertexNormals:{get:m.throwInstantiationError},availability:{get:m.throwInstantiationError}});var f=[];T.getRegularGridIndices=function(t,e){if(t*e>=d.FOUR_GIGABYTES)throw new m("The total number of vertices (width * height) must be less than 4,294,967,296.");let r=f[t];g(r)||(f[t]=r=[]);let i=r[e];return g(i)||(i=t*e<d.SIXTY_FOUR_KILOBYTES?r[e]=new Uint16Array((t-1)*(e-1)*6):r[e]=new Uint32Array((t-1)*(e-1)*6),y(t,e,i,0)),i};var N=[];T.getRegularGridIndicesAndEdgeIndices=function(t,e){if(t*e>=d.FOUR_GIGABYTES)throw new m("The total number of vertices (width * height) must be less than 4,294,967,296.");let r=N[t];g(r)||(N[t]=r=[]);let i=r[e];if(!g(i)){let n=T.getRegularGridIndices(t,e),o=E(t,e),a=o.westIndicesSouthToNorth,s=o.southIndicesEastToWest,h=o.eastIndicesNorthToSouth,u=o.northIndicesWestToEast;i=r[e]={indices:n,westIndicesSouthToNorth:a,southIndicesEastToWest:s,eastIndicesNorthToSouth:h,northIndicesWestToEast:u}}return i};var p=[];function E(t,e){let r=Array(e),i=Array(t),n=Array(e),o=Array(t),a;for(a=0;a<t;++a)o[a]=a,i[a]=t*e-1-a;for(a=0;a<e;++a)n[a]=(a+1)*t-1,r[a]=(e-a-1)*t;return{westIndicesSouthToNorth:r,southIndicesEastToWest:i,eastIndicesNorthToSouth:n,northIndicesWestToEast:o}}function y(t,e,r,i){let n=0;for(let o=0;o<e-1;++o){for(let e=0;e<t-1;++e){let e=n,o=e+t,a=o+1,s=e+1;r[i++]=e,r[i++]=o,r[i++]=s,r[i++]=s,r[i++]=o,r[i++]=a,++n}++n}}function S(t,e,r,i){let n=t[0],o=t.length;for(let a=1;a<o;++a){let o=t[a];r[i++]=n,r[i++]=o,r[i++]=e,r[i++]=e,r[i++]=o,r[i++]=e+1,n=o,++e}return i}T.getRegularGridAndSkirtIndicesAndEdgeIndices=function(t,e){if(t*e>=d.FOUR_GIGABYTES)throw new m("The total number of vertices (width * height) must be less than 4,294,967,296.");let r=p[t];g(r)||(p[t]=r=[]);let i=r[e];if(!g(i)){let n=t*e,a=(t-1)*(e-1)*6,s=2*t+2*e,h=6*Math.max(0,s-4),u=E(t,e),c=u.westIndicesSouthToNorth,l=u.southIndicesEastToWest,I=u.eastIndicesNorthToSouth,d=u.northIndicesWestToEast,m=o.createTypedArray(n+s,a+h);y(t,e,m,0),T.addSkirtIndices(c,l,I,d,n,m,a),i=r[e]={indices:m,westIndicesSouthToNorth:c,southIndicesEastToWest:l,eastIndicesNorthToSouth:I,northIndicesWestToEast:d,indexCountWithoutSkirts:a}}return i},T.addSkirtIndices=function(t,e,r,i,n,o,a){let s=n;a=S(t,s,o,a),s+=t.length,a=S(e,s,o,a),s+=e.length,a=S(r,s,o,a),S(i,s+=r.length,o,a)},T.heightmapTerrainQuality=.25,T.getEstimatedLevelZeroGeometricErrorForAHeightmap=function(t,e,r){return 2*t.maximumRadius*Math.PI*T.heightmapTerrainQuality/(e*r)},T.prototype.requestTileGeometry=m.throwInstantiationError,T.prototype.getLevelMaximumGeometricError=m.throwInstantiationError,T.prototype.getTileDataAvailable=m.throwInstantiationError,T.prototype.loadTileDataAvailability=m.throwInstantiationError;var w=new u,A=new u,b=new u,k=new c,x=new l;function W(t,e,r,i,n,o,s,h,c){let l=Number.POSITIVE_INFINITY,I=n.north,m=n.south,g=n.east,T=n.west;g<T&&(g+=d.TWO_PI);let f=t.length;for(let n=0;n<f;++n){let f=t[n],N=r[f],p=i[f];k.longitude=d.lerp(T,g,p.x),k.latitude=d.lerp(m,I,p.y),k.height=N-e;let E=o.cartographicToCartesian(k,w);a.multiplyByPoint(s,E,E),u.minimumByComponent(E,h,h),u.maximumByComponent(E,c,c),l=Math.min(l,k.height)}return l}function F(t,e,r,n,o,a,s,h,u,c,l,I,m,T){let f=g(s),N=u.north,p=u.south,E=u.east,y=u.west;E<y&&(E+=d.TWO_PI);let S=r.length;for(let u=0;u<S;++u){let g,S,A=r[u],b=o[A],W=a[A];k.longitude=d.lerp(y,E,W.x)+m,k.latitude=d.lerp(p,N,W.y)+T,k.height=b-c;let F=h.cartographicToCartesian(k,w);if(f){let t=2*A;x.x=s[t],x.y=s[t+1]}n.hasWebMercatorT&&(g=(i.geodeticLatitudeToMercatorAngle(k.latitude)-l)*I),n.hasGeodeticSurfaceNormals&&(S=h.geodeticSurfaceNormal(F)),e=n.encode(t,e,F,W,k.height,x,g,S)}}function G(t,e){let r;return"function"==typeof t.slice&&"function"!=typeof(r=t.slice()).sort&&(r=void 0),g(r)||(r=Array.prototype.slice.call(t)),r.sort(e),r}var M=r(function(r,c){let m=r.quantizedVertices,f=m.length/3,N=r.octEncodedNormals,p=r.westIndices.length+r.eastIndices.length+r.southIndices.length+r.northIndices.length,E=r.includeWebMercatorT,y=r.exaggeration,S=r.exaggerationRelativeHeight,M=1!==y,v=h.clone(r.rectangle),P=v.west,V=v.south,Y=v.east,_=v.north,j=I.clone(r.ellipsoid),B=r.minimumHeight,H=r.maximumHeight,R=r.relativeToCenter,C=s.eastNorthUpToFixedFrame(R,j),O=a.inverseTransformation(C,new a),L,U;E&&(L=i.geodeticLatitudeToMercatorAngle(V),U=1/(i.geodeticLatitudeToMercatorAngle(_)-L));let K=m.subarray(0,f),z=m.subarray(f,2*f),D=m.subarray(2*f,3*f),J=g(N),Q=Array(f),Z=Array(f),q=Array(f),X=E?Array(f):[],$=M?Array(f):[];A.x=Number.POSITIVE_INFINITY,A.y=Number.POSITIVE_INFINITY,A.z=Number.POSITIVE_INFINITY,b.x=Number.NEGATIVE_INFINITY,b.y=Number.NEGATIVE_INFINITY,b.z=Number.NEGATIVE_INFINITY;let tt=Number.POSITIVE_INFINITY,te=Number.NEGATIVE_INFINITY,tr=Number.POSITIVE_INFINITY,ti=Number.NEGATIVE_INFINITY;for(let t=0;t<f;++t){let e=K[t],r=z[t],n=e/32767,o=r/32767,s=d.lerp(B,H,D[t]/32767);k.longitude=d.lerp(P,Y,n),k.latitude=d.lerp(V,_,o),k.height=s,tt=Math.min(k.longitude,tt),te=Math.max(k.longitude,te),tr=Math.min(k.latitude,tr),ti=Math.max(k.latitude,ti);let h=j.cartographicToCartesian(k);Q[t]=new l(n,o),Z[t]=s,q[t]=h,E&&(X[t]=(i.geodeticLatitudeToMercatorAngle(k.latitude)-L)*U),M&&($[t]=j.geodeticSurfaceNormal(h)),a.multiplyByPoint(O,h,w),u.minimumByComponent(w,A,A),u.maximumByComponent(w,b,b)}let tn=G(r.westIndices,function(t,e){return Q[t].y-Q[e].y}),to=G(r.eastIndices,function(t,e){return Q[e].y-Q[t].y}),ta=G(r.southIndices,function(t,e){return Q[e].x-Q[t].x}),ts=G(r.northIndices,function(t,e){return Q[t].x-Q[e].x}),th;B<0&&(th=new t(j).computeHorizonCullingPointPossiblyUnderEllipsoid(R,q,B));let tu=B;tu=Math.min(tu=Math.min(tu=Math.min(tu=Math.min(tu,W(r.westIndices,r.westSkirtHeight,Z,Q,v,j,O,A,b)),W(r.southIndices,r.southSkirtHeight,Z,Q,v,j,O,A,b)),W(r.eastIndices,r.eastSkirtHeight,Z,Q,v,j,O,A,b)),W(r.northIndices,r.northSkirtHeight,Z,Q,v,j,O,A,b));let tc=new n(A,b,R),tl=new e(R,tc,tu,H,C,J,E,M,y,S),tI=tl.stride,td=new Float32Array(f*tI+p*tI),tm=0;for(let t=0;t<f;++t){if(J){let e=2*t;x.x=N[e],x.y=N[e+1]}tm=tl.encode(td,tm,q[t],Q[t],Z[t],x,X[t],$[t])}let tg=Math.max(0,(p-4)*2),tT=r.indices.length+3*tg,tf=o.createTypedArray(f+p,tT);tf.set(r.indices,0);let tN=(te-tt)*1e-4,tp=(ti-tr)*1e-4,tE=f*tI;return F(td,tE,tn,tl,Z,Q,N,j,v,r.westSkirtHeight,L,U,-tN,0),F(td,tE+=r.westIndices.length*tI,ta,tl,Z,Q,N,j,v,r.southSkirtHeight,L,U,0,-tp),F(td,tE+=r.southIndices.length*tI,to,tl,Z,Q,N,j,v,r.eastSkirtHeight,L,U,tN,0),F(td,tE+=r.eastIndices.length*tI,ts,tl,Z,Q,N,j,v,r.northSkirtHeight,L,U,0,tp),T.addSkirtIndices(tn,ta,to,ts,f,tf,r.indices.length),c.push(td.buffer,tf.buffer),{vertices:td.buffer,indices:tf.buffer,westIndicesSouthToNorth:tn,southIndicesEastToWest:ta,eastIndicesNorthToSouth:to,northIndicesWestToEast:ts,vertexStride:tI,center:R,minimumHeight:B,maximumHeight:H,occludeePointInScaledSpace:th,encoding:tl,indexCountWithoutSkirts:r.indices.length}});export{M as default};