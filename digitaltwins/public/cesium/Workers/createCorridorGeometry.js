import{a as t}from"./chunk-UV3CO6HM.js";import{a as e}from"./chunk-6BHHTHKE.js";import"./chunk-M5SITFFN.js";import"./chunk-ZPYKVVFF.js";import{a as r}from"./chunk-ZFTFDHK4.js";import{a as o}from"./chunk-74GQJJ7R.js";import"./chunk-FNJKWSPR.js";import"./chunk-KSZ5EBRB.js";import{b as i}from"./chunk-CKMJZ5B3.js";import{a as a}from"./chunk-WNTCOVG2.js";import"./chunk-EEKB62LQ.js";import"./chunk-V3DSE3OK.js";import"./chunk-FMRIJYNG.js";import{a as n}from"./chunk-NNHN6WUY.js";import{a as l}from"./chunk-T7ERZ2CJ.js";import{b as s,c as u,d as d}from"./chunk-GSNDLQ4C.js";import{d as m}from"./chunk-BKSIEBAA.js";import{h as h}from"./chunk-YWRPWWKI.js";import{a as c}from"./chunk-VTVHUB7E.js";import{a as f,b as p,d as g}from"./chunk-JMSSU44E.js";import{a as A}from"./chunk-4UYSGV57.js";import"./chunk-ANLJ4KBN.js";import"./chunk-ID6SFQTL.js";import{a as b}from"./chunk-VLPNAR64.js";import{b as y}from"./chunk-GE5NEIZC.js";import{e as _}from"./chunk-35CVRQTC.js";var w=new f,v=new f,T=new f,N=new f,E=new f,k=new f,F=new f,I=new f;function O(t,e){for(let r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function P(e,r,o,i,a,n){let l=e.normals,s=e.tangents,u=e.bitangents,d=f.normalize(f.cross(o,r,F),F);n.normal&&t.addAttribute(l,r,i,a),n.tangent&&t.addAttribute(s,d,i,a),n.bitangent&&t.addAttribute(u,o,i,a)}function M(e,r,o){let i,a,s=e.positions,u=e.corners,m=e.endPositions,h=e.lefts,p=e.normals,g=new l,b,y=0,E=0,O,M=0,S;for(O=0;O<s.length;O+=2)y+=S=s[O].length-3,M+=2*S,E+=s[O+1].length-3;for(y+=3,E+=3,O=0;O<u.length;O++){b=u[O];let t=u[O].leftPositions;_(t)?y+=S=t.length:E+=S=u[O].rightPositions.length,M+=S}let V=_(m),x;V&&(y+=x=m[0].length-3,E+=x,x/=3,M+=6*x);let j=y+E,D=new Float64Array(j),L={normals:r.normal?new Float32Array(j):void 0,tangents:r.tangent?new Float32Array(j):void 0,bitangents:r.bitangent?new Float32Array(j):void 0},R=0,H=j-1,G,B,C,U,Y=w,z=v,K,J,W=x/2,Z=n.createTypedArray(j/3,M),Q=0;if(V){J=T,K=N;let e=m[0];for(Y=f.fromArray(p,0,Y),z=f.fromArray(h,0,z),O=0;O<W;O++)J=f.fromArray(e,(W-1-O)*3,J),K=f.fromArray(e,(W+O)*3,K),t.addAttribute(D,K,R),t.addAttribute(D,J,void 0,H),P(L,Y,z,R,H,r),U=(B=R/3)+1,C=(G=(H-2)/3)-1,Z[Q++]=G,Z[Q++]=B,Z[Q++]=C,Z[Q++]=C,Z[Q++]=B,Z[Q++]=U,R+=3,H-=3}let q=0,X=0,$=s[q++],tt=s[q++];for(D.set($,R),D.set(tt,H-tt.length+1),z=f.fromArray(h,X,z),S=tt.length-3,O=0;O<S;O+=3)i=o.geodeticSurfaceNormal(f.fromArray($,O,F),F),a=o.geodeticSurfaceNormal(f.fromArray(tt,S-O,I),I),P(L,Y=f.normalize(f.add(i,a,Y),Y),z,R,H,r),U=(B=R/3)+1,C=(G=(H-2)/3)-1,Z[Q++]=G,Z[Q++]=B,Z[Q++]=C,Z[Q++]=C,Z[Q++]=B,Z[Q++]=U,R+=3,H-=3;for(i=o.geodeticSurfaceNormal(f.fromArray($,S,F),F),a=o.geodeticSurfaceNormal(f.fromArray(tt,S,I),I),Y=f.normalize(f.add(i,a,Y),Y),X+=3,O=0;O<u.length;O++){let e;let n=(b=u[O]).leftPositions,l=b.rightPositions,d,m,c=k,g=T,A=N;if(Y=f.fromArray(p,X,Y),_(n)){for(P(L,Y,z,void 0,H,r),H-=3,d=U,m=C,e=0;e<n.length/3;e++)c=f.fromArray(n,3*e,c),Z[Q++]=d,Z[Q++]=m-e-1,Z[Q++]=m-e,t.addAttribute(D,c,void 0,H),g=f.fromArray(D,(m-e-1)*3,g),A=f.fromArray(D,3*d,A),P(L,Y,z=f.normalize(f.subtract(g,A,z),z),void 0,H,r),H-=3;c=f.fromArray(D,3*d,c),g=f.subtract(f.fromArray(D,3*m,g),c,g),A=f.subtract(f.fromArray(D,(m-e)*3,A),c,A),P(L,Y,z=f.normalize(f.add(g,A,z),z),R,void 0,r),R+=3}else{for(P(L,Y,z,R,void 0,r),R+=3,d=C,m=U,e=0;e<l.length/3;e++)c=f.fromArray(l,3*e,c),Z[Q++]=d,Z[Q++]=m+e,Z[Q++]=m+e+1,t.addAttribute(D,c,R),g=f.fromArray(D,3*d,g),A=f.fromArray(D,(m+e)*3,A),P(L,Y,z=f.normalize(f.subtract(g,A,z),z),R,void 0,r),R+=3;c=f.fromArray(D,3*d,c),g=f.subtract(f.fromArray(D,(m+e)*3,g),c,g),A=f.subtract(f.fromArray(D,3*m,A),c,A),P(L,Y,z=f.normalize(f.negate(f.add(A,g,z),z),z),void 0,H,r),H-=3}for($=s[q++],tt=s[q++],$.splice(0,3),tt.splice(tt.length-3,3),D.set($,R),D.set(tt,H-tt.length+1),S=tt.length-3,X+=3,z=f.fromArray(h,X,z),e=0;e<tt.length;e+=3)i=o.geodeticSurfaceNormal(f.fromArray($,e,F),F),a=o.geodeticSurfaceNormal(f.fromArray(tt,S-e,I),I),P(L,Y=f.normalize(f.add(i,a,Y),Y),z,R,H,r),B=(U=R/3)-1,G=(C=(H-2)/3)+1,Z[Q++]=G,Z[Q++]=B,Z[Q++]=C,Z[Q++]=C,Z[Q++]=B,Z[Q++]=U,R+=3,H-=3;R-=3,H+=3}if(P(L,Y=f.fromArray(p,p.length-3,Y),z,R,H,r),V){R+=3,H-=3,J=T,K=N;let e=m[1];for(O=0;O<W;O++)J=f.fromArray(e,(x-O-1)*3,J),K=f.fromArray(e,3*O,K),t.addAttribute(D,J,void 0,H),t.addAttribute(D,K,R),P(L,Y,z,R,H,r),B=(U=R/3)-1,G=(C=(H-2)/3)+1,Z[Q++]=G,Z[Q++]=B,Z[Q++]=C,Z[Q++]=C,Z[Q++]=B,Z[Q++]=U,R+=3,H-=3}if(g.position=new d({componentDatatype:c.DOUBLE,componentsPerAttribute:3,values:D}),r.st){let t=new Float32Array(j/3*2),e,r,o=0;if(V){y/=3,E/=3;let i=Math.PI/(x+1);r=1/(y-x+1),e=1/(E-x+1);let a,n=x/2;for(O=n+1;O<x+1;O++)a=A.PI_OVER_TWO+i*O,t[o++]=e*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a));for(O=1;O<E-x+1;O++)t[o++]=O*e,t[o++]=0;for(O=x;O>n;O--)a=A.PI_OVER_TWO-O*i,t[o++]=1-e*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a));for(O=n;O>0;O--)a=A.PI_OVER_TWO-i*O,t[o++]=1-r*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a));for(O=y-x;O>0;O--)t[o++]=O*r,t[o++]=1;for(O=1;O<n+1;O++)a=A.PI_OVER_TWO+i*O,t[o++]=r*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a))}else{for(y/=3,E/=3,r=1/(y-1),e=1/(E-1),O=0;O<E;O++)t[o++]=O*e,t[o++]=0;for(O=y;O>0;O--)t[o++]=(O-1)*r,t[o++]=1}g.st=new d({componentDatatype:c.FLOAT,componentsPerAttribute:2,values:t})}return r.normal&&(g.normal=new d({componentDatatype:c.FLOAT,componentsPerAttribute:3,values:L.normals})),r.tangent&&(g.tangent=new d({componentDatatype:c.FLOAT,componentsPerAttribute:3,values:L.tangents})),r.bitangent&&(g.bitangent=new d({componentDatatype:c.FLOAT,componentsPerAttribute:3,values:L.bitangents})),{attributes:g,indices:Z}}function S(t,e,r){r[e++]=t[0],r[e++]=t[1],r[e++]=t[2];for(let o=3;o<t.length;o+=3){let i=t[o],a=t[o+1],n=t[o+2];r[e++]=i,r[e++]=a,r[e++]=n,r[e++]=i,r[e++]=a,r[e++]=n}return r[e++]=t[0],r[e++]=t[1],r[e++]=t[2],r}var V=new f,x=new f,j=new p;function D(t,e,r,o,i,a){let n=f.subtract(e,t,V);f.normalize(n,n);let l=r.geodeticSurfaceNormal(t,x),s=f.cross(n,l,V);f.multiplyByScalar(s,o,s);let u=i.latitude,d=i.longitude,m=a.latitude,h=a.longitude;f.add(t,s,x),r.cartesianToCartographic(x,j);let c=j.latitude,p=j.longitude;u=Math.min(u,c),d=Math.min(d,p),m=Math.max(m,c),h=Math.max(h,p),f.subtract(t,s,x),r.cartesianToCartographic(x,j),c=j.latitude,p=j.longitude,u=Math.min(u,c),d=Math.min(d,p),m=Math.max(m,c),h=Math.max(h,p),i.latitude=u,i.longitude=d,a.latitude=m,a.longitude=h}var L=new f,R=new f,H=new p,G=new p;function B(t,r,o,i,n){let l,s;let u=a(t=O(t,r),f.equalsEpsilon),d=u.length;if(d<2||o<=0)return new h;let m=.5*o;if(H.latitude=Number.POSITIVE_INFINITY,H.longitude=Number.POSITIVE_INFINITY,G.latitude=Number.NEGATIVE_INFINITY,G.longitude=Number.NEGATIVE_INFINITY,i===e.ROUNDED){let t=u[0];f.subtract(t,u[1],L),f.normalize(L,L),f.multiplyByScalar(L,m,L),f.add(t,L,R),r.cartesianToCartographic(R,j),l=j.latitude,s=j.longitude,H.latitude=Math.min(H.latitude,l),H.longitude=Math.min(H.longitude,s),G.latitude=Math.max(G.latitude,l),G.longitude=Math.max(G.longitude,s)}for(let t=0;t<d-1;++t)D(u[t],u[t+1],r,m,H,G);let c=u[d-1];f.subtract(c,u[d-2],L),f.normalize(L,L),f.multiplyByScalar(L,m,L),f.add(c,L,R),D(c,R,r,m,H,G),i===e.ROUNDED&&(r.cartesianToCartographic(R,j),l=j.latitude,s=j.longitude,H.latitude=Math.min(H.latitude,l),H.longitude=Math.min(H.longitude,s),G.latitude=Math.max(G.latitude,l),G.longitude=Math.max(G.longitude,s));let p=_(n)?n:new h;return p.north=G.latitude,p.south=H.latitude,p.east=G.longitude,p.west=H.longitude,p}function C(t){let r=(t=b(t,b.EMPTY_OBJECT)).positions,i=t.width;y.defined("options.positions",r),y.defined("options.width",i);let a=b(t.height,0),n=b(t.extrudedHeight,a);this._positions=r,this._ellipsoid=g.clone(b(t.ellipsoid,g.default)),this._vertexFormat=o.clone(b(t.vertexFormat,o.DEFAULT)),this._width=i,this._height=Math.max(a,n),this._extrudedHeight=Math.min(a,n),this._cornerType=b(t.cornerType,e.ROUNDED),this._granularity=b(t.granularity,A.RADIANS_PER_DEGREE),this._shadowVolume=b(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+r.length*f.packedLength+g.packedLength+o.packedLength+7}C.pack=function(t,e,r){y.defined("value",t),y.defined("array",e),r=b(r,0);let i=t._positions,a=i.length;e[r++]=a;for(let t=0;t<a;++t,r+=f.packedLength)f.pack(i[t],e,r);return g.pack(t._ellipsoid,e,r),r+=g.packedLength,o.pack(t._vertexFormat,e,r),r+=o.packedLength,e[r++]=t._width,e[r++]=t._height,e[r++]=t._extrudedHeight,e[r++]=t._cornerType,e[r++]=t._granularity,e[r++]=+!!t._shadowVolume,e[r]=b(t._offsetAttribute,-1),e};var U=g.clone(g.UNIT_SPHERE),Y=new o,z={positions:void 0,ellipsoid:U,vertexFormat:Y,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};C.unpack=function(t,e,r){y.defined("array",t),e=b(e,0);let i=t[e++],a=Array(i);for(let r=0;r<i;++r,e+=f.packedLength)a[r]=f.unpack(t,e);let n=g.unpack(t,e,U);e+=g.packedLength;let l=o.unpack(t,e,Y);e+=o.packedLength;let s=t[e++],u=t[e++],d=t[e++],m=t[e++],h=t[e++],c=1===t[e++],p=t[e];return _(r)?(r._positions=a,r._ellipsoid=g.clone(n,r._ellipsoid),r._vertexFormat=o.clone(l,r._vertexFormat),r._width=s,r._height=u,r._extrudedHeight=d,r._cornerType=m,r._granularity=h,r._shadowVolume=c,r._offsetAttribute=-1===p?void 0:p,r):(z.positions=a,z.width=s,z.height=u,z.extrudedHeight=d,z.cornerType=m,z.granularity=h,z.shadowVolume=c,z.offsetAttribute=-1===p?void 0:p,new C(z))},C.computeRectangle=function(t,r){let o=(t=b(t,b.EMPTY_OBJECT)).positions,i=t.width;return y.defined("options.positions",o),y.defined("options.width",i),B(o,b(t.ellipsoid,g.default),i,b(t.cornerType,e.ROUNDED),r)},C.createGeometry=function(e){let l=e._positions,h=e._width,p=e._ellipsoid,g=a(l=O(l,p),f.equalsEpsilon);if(g.length<2||h<=0)return;let b=e._height,y=e._extrudedHeight,F=!A.equalsEpsilon(b,y,0,A.EPSILON2),I=e._vertexFormat,P={ellipsoid:p,positions:g,width:h,cornerType:e._cornerType,granularity:e._granularity,saveAttributes:!0},V;if(F)P.height=b,P.extrudedHeight=y,P.shadowVolume=e._shadowVolume,P.offsetAttribute=e._offsetAttribute,V=function(e,a){let l,s,u,m,h=new o({position:a.position,normal:a.normal||a.bitangent||e.shadowVolume,tangent:a.tangent,bitangent:a.normal||a.bitangent,st:a.st}),p=e.ellipsoid,g=M(t.computePositions(e),h,p),A=e.height,b=e.extrudedHeight,y=g.attributes,F=g.indices,I=y.position.values,O=I.length,P=new Float64Array(6*O),V=new Float64Array(O);V.set(I);let x=new Float64Array(4*O);x=S(I=i.scaleToGeodeticHeight(I,A,p),0,x),x=S(V=i.scaleToGeodeticHeight(V,b,p),2*O,x),P.set(I),P.set(V,O),P.set(x,2*O),y.position.values=P,y=function(e,r){if(!r.normal&&!r.tangent&&!r.bitangent&&!r.st)return e;let o=e.position.values,i,a;(r.normal||r.bitangent)&&(i=e.normal.values,a=e.bitangent.values);let n=e.position.values.length/18,l=3*n,s=2*n,u=2*l,d;if(r.normal||r.bitangent||r.tangent){let n=r.normal?new Float32Array(6*l):void 0,s=r.tangent?new Float32Array(6*l):void 0,m=r.bitangent?new Float32Array(6*l):void 0,h=w,c=v,p=T,g=N,A=E,b=k,y=u;for(d=0;d<l;d+=3){let e=y+u;h=f.fromArray(o,d,h),c=f.fromArray(o,d+l,c),p=f.fromArray(o,(d+3)%l,p),c=f.subtract(c,h,c),p=f.subtract(p,h,p),g=f.normalize(f.cross(c,p,g),g),r.normal&&(t.addAttribute(n,g,e),t.addAttribute(n,g,e+3),t.addAttribute(n,g,y),t.addAttribute(n,g,y+3)),(r.tangent||r.bitangent)&&(b=f.fromArray(i,d,b),r.bitangent&&(t.addAttribute(m,b,e),t.addAttribute(m,b,e+3),t.addAttribute(m,b,y),t.addAttribute(m,b,y+3)),r.tangent&&(A=f.normalize(f.cross(b,g,A),A),t.addAttribute(s,A,e),t.addAttribute(s,A,e+3),t.addAttribute(s,A,y),t.addAttribute(s,A,y+3))),y+=6}if(r.normal){for(n.set(i),d=0;d<l;d+=3)n[d+l]=-i[d],n[d+l+1]=-i[d+1],n[d+l+2]=-i[d+2];e.normal.values=n}else e.normal=void 0;if(r.bitangent?(m.set(a),m.set(a,l),e.bitangent.values=m):e.bitangent=void 0,r.tangent){let t=e.tangent.values;s.set(t),s.set(t,l),e.tangent.values=s}}if(r.st){let t=e.st.values,r=new Float32Array(6*s);r.set(t),r.set(t,s);let o=2*s;for(let e=0;e<2;e++){for(r[o++]=t[0],r[o++]=t[1],d=2;d<s;d+=2){let e=t[d],i=t[d+1];r[o++]=e,r[o++]=i,r[o++]=e,r[o++]=i}r[o++]=t[0],r[o++]=t[1]}e.st.values=r}return e}(y,a);let j,D=O/3;if(e.shadowVolume){let t=y.normal.values,e=new Float32Array(6*(O=t.length));for(j=0;j<O;j++)t[j]=-t[j];e.set(t,O),e=S(t,4*O,e),y.extrudeDirection=new d({componentDatatype:c.FLOAT,componentsPerAttribute:3,values:e}),a.normal||(y.normal=void 0)}if(_(e.offsetAttribute)){let t=new Uint8Array(6*D);if(e.offsetAttribute===r.TOP)t=t.fill(1,0,D).fill(1,2*D,4*D);else{let o=+(e.offsetAttribute!==r.NONE);t=t.fill(o)}y.applyOffset=new d({componentDatatype:c.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}let L=F.length,R=D+D,H=n.createTypedArray(P.length/3,2*L+3*R);H.set(F);let G=L;for(j=0;j<L;j+=3){let t=F[j],e=F[j+1],r=F[j+2];H[G++]=r+D,H[G++]=e+D,H[G++]=t+D}for(j=0;j<R;j+=2)s=(l=j+R)+R,u=l+1,m=s+1,H[G++]=l,H[G++]=s,H[G++]=u,H[G++]=u,H[G++]=s,H[G++]=m;return{attributes:y,indices:H}}(P,I);else if((V=M(t.computePositions(P),I,p)).attributes.position.values=i.scaleToGeodeticHeight(V.attributes.position.values,b,p),_(e._offsetAttribute)){let t=+(e._offsetAttribute!==r.NONE),o=new Uint8Array(V.attributes.position.values.length/3).fill(t);V.attributes.applyOffset=new d({componentDatatype:c.UNSIGNED_BYTE,componentsPerAttribute:1,values:o})}let x=V.attributes,j=m.fromVertices(x.position.values,void 0,3);return I.position||(V.attributes.position.values=void 0),new u({attributes:x,indices:V.indices,primitiveType:s.TRIANGLES,boundingSphere:j,offsetAttribute:e._offsetAttribute})},C.createShadowVolume=function(t,e,r){let i=t._granularity,a=t._ellipsoid,n=e(i,a),l=r(i,a);return new C({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:a,granularity:i,extrudedHeight:n,height:l,vertexFormat:o.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(C.prototype,{rectangle:{get:function(){return _(this._rectangle)||(this._rectangle=B(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}});var K=function(t,e){return _(e)&&(t=C.unpack(t,e)),t._ellipsoid=g.clone(t._ellipsoid),C.createGeometry(t)};export{K as default};